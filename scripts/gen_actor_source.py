#!/usr/bin/python
#coding=utf-8

"""
Generates and keeps up-to-date actor skeleton sources.

Usage:
    gen_actor_source.py (--project|--update) DECLARATION.json

    --project       Run in generate project mode
    --update        Run in update files mode (used from Makefiles)

Example (create new actor skeleton):
    cd kumir2/src/actors
    mkdir mygreatactor
    cd mygreatactor
    { ... create here file mygreatactor.json ...}
    ../../../scripts/gen_actor_source.py --project mygreatactor.json

This will create the following files:
    MyGreatActor.pluginspec     -- actor plugin spec
    CMakeLists.txt              -- CMake project file
    mygreatactormodule.h        -- header skeleton
    mygreatactormodule.cpp      -- source skeleton

===

                        0. INTRODUCTION

The module operates in two ways:
1. Update project files. Usually called from CMakeLists.txt within build process.
2. Create new project. Creates project file (CMakeLists.txt) and module skeleton.


                        1. CODE LAYOUT

Here are two group of classes. The first one covers module description tree, while
the second one covers generated files implementation.


1.1. Module description class group

The module description input data represented as JSON-file, handled by Python as
a dictionary object. Parsing this dictionary, the following structure produces
(here '+' significates 'one or more', '*' is 'zero or none', '?' is 'zero or one',
and '|' is 'or'):

    class Module (a top level class of tree) :=
        name: class Name
        methods: (class Method)+
        types: (class BaseType)*
        gui: (class Gui)?
        settings: (class Settings)?

    class Name: a Kumir/C++ name representation

    class Method :=
        name: class Name
        returnType: class BaseType | None
        async: bool
        arguments: (class Argument)*

    class BaseType :=
        name: class Name
        standard: bool
        fields: ( <class Name, class BaseType> )*

    class Argument :=
        name: class Name
        baseType: class BaseType
        dimension: [0, 1, 2, 3]
        constatnt: bool
        reference: bool
        readable: bool

    class Gui :=
        windows: (class Window)*
        menus: (class MenuItem)*

    class Window :=
        icon: string
        role: string

    class MenuItem :=
        title: class Name
        icon: string | None
        items: (class MenuItem)*

    class Settings :=
        entries: (class SettingsEntry)*

    class SettingsEntry :=
        key: string
        title: class Name
        type: string
        default: string
        minimum: string | None
        maximum: string | None


1.2. Module implementation class group

After the JSON file is read and corresponding module tree is built, the next
stage is to generate source files.

There are four C++ modules generated by the module description:


1.2.1. Module Qt-Plugin class (here is class PluginCppClass)

The Kumir's extension system module, implements Actor interface. Provides
actor information to Kumir. This class code is auto generated and not ought to
be modified.


1.2.2. Module implementation base class (here is ModuleBaseCppClass)

A class to be inherited by implementation. The class contains mostly pure virtual
methods according to actor algorithms headers (in C++ syntax). This class
is auto generated and not ought to be modified.

1.2.3. Module implementation skeleton (here is ModuleCppClass)

A skeleton files to be implemented by actor functionality. The class inherits
auto-generated base to match up-to-date actor description. The class generates once and
must be implemented by actor developer.

1.2.4. Async run thread class (here is AsyncThreadCppClass)

A supplementary class, which declared and implemented near plugin class in the same files.
Some actor methods should be 'Asynchronous', what means that they run in separate thread.
This class provides transparent and convient layout to developer not to implement this
feature hisself.


                        2. SCRIPT WORKFLOW

The first, script reads provided JSON file and creates an actor module description tree
(class Module instance).

Then, there are two modes of operation: generate an update set of files, or generate a
project set of files.


2.1. Update set of files

In this mode the following files generated:
    - actor plugin header (function createPluginHeaderFile);
    - actor plugin source (function createPluginSourceFile);
    - actor implementation base header (function createModuleBaseHeaderFile);
    - actor implementation base source (function createModuleBaseSourceFile);
    - actor plugin specification (function createPluginSpecFile).

2.2. Project set of files

In this mode the following files generated:
    - actor implementation header (function createModuleHeaderFile);
    - actor implementation source (function createModuleSourceFile);
    - actor project file (function createCMakeListsTxt);
    - actor documentation file (function createDocbookFile).

"""
import copy
import sys
import json
import string
import os
import inspect


MODULE_CLASS_SUFFIX = "Module"
MODULE_BASE_CLASS_SUFFIX = "ModuleBase"
MODULE_RUN_THREAD_SUFFIX = "AsyncRunThread"
MODULE_PLUGIN_CLASS_SUFFIX = "Plugin"
MODULE_NAMESPACE_PREFIX = "Actor"


def _renderTemplate(template, values):
    """
    Renders simple template using $-substitutions

    :param template:    template to render
    :type template:     str
    :type values:       dict
    :param values:      values to substitute
    :rtype:             unicode
    :return:            a string with replaced substitutions
    """
    assert isinstance(template, str) or isinstance(template, unicode)
    assert isinstance(values, dict)
    for key, value in values.items():
        template = template.replace("$" + key, value)
    return template


def _addIndent(text):
    """
    Adds a one indent (4 spaces) to each line of text

    :type text:     unicode or str
    :param text:    text to indent
    :rtype:         unicode
    :return:        4-space indented text
    """
    assert isinstance(text, unicode) or isinstance(text, str)
    lines = text.split('\n')
    indentedLines = map(lambda x: "    " + x, lines)
    return string.join(indentedLines, '\n')


# The group of module description tree classes

class Name:
    """
    A class representing localizable name.
    """

    def __init__(self, jsonNode):
        """
        Initializes from JSON value
        """
        assert isinstance(jsonNode, dict) or isinstance(jsonNode, str) or isinstance(jsonNode, unicode)
        if isinstance(jsonNode, dict):
            assert "ascii" in jsonNode
            self.data = jsonNode
        else:
            self.data = dict()
            self.data["ascii"] = unicode(jsonNode)

    def kumirValue(self):
        """
        Returns an Unicode representation for Russian language or ASCII

        :rtype:     unicode
        :return:    name as is
        """
        if "ru_RU" in self.data:
            return unicode(self.data["ru_RU"])
        else:
            return unicode(self.data["ascii"])

    def asciiValue(self):
        """
        Returns an ASCII representation

        :rtype:     str
        :return:    ASCII name as is
        """
        return str(self.data["ascii"])

    def cppValue(self):
        """
        Returns a valid C++ name based on source name

        :rtype:     str
        :return:    valid C++ identifier
        """
        result = ""
        nextIsCap = False
        ascii = self.data["ascii"]
        if ascii == "+":
            return "OperatorPLUS"
        elif ascii == "-":
            return "OperatorMINUS"
        elif ascii == "*":
            return "OperatorASTERISK"
        elif ascii == "**":
            return "OperatorPOWER"
        elif ascii == "/":
            return "OperatorSLASH"
        elif ascii == "=":
            return "OperatorEQUAL"
        elif ascii == "<":
            return "OperatorLESS"
        elif ascii == ">":
            return "OperatorGREATER"
        elif ascii.startswith(":="):
            return "OperatorASSIGN"
        elif ascii == "input":
            return "OperatorINPUT"
        elif ascii == "output":
            return "OperatorOUTPUT"
        for c in ascii:
            if c == ' ':
                nextIsCap = True
            else:
                if nextIsCap:
                    result += c.upper()
                elif c.upper() in "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_":
                    result += c
                nextIsCap = False
        result = result.replace("#", "").replace("?", "").replace("!", "")
        return result

    def cppCamelCaseValue(self):
        """
        Returns a valid CamelCase C++ name based on source name

        :rtype:     str
        :return:    valid C++ identifier
        """
        cpp = self.cppValue()
        return cpp[0].upper() + cpp[1:]


class BaseType:
    """
    Scalar data type
    """
    _typeTable = dict()  # a table of actor's custom types

    def __init__(self, jsonNode):
        """
        Initializes from  JSON value or uses existing type

        :type   jsonNode: dict, str, unicode
        :param  jsonNode: JSON node for custom type or name for standard type
        """
        assert isinstance(jsonNode, dict) or isinstance(jsonNode, str) or isinstance(jsonNode, unicode)
        if isinstance(jsonNode, dict):
            self.__init__from_dict(jsonNode)
        else:
            self.__init__from_string(str(jsonNode))

    def __init__from_dict(self, jsonNode):
        """
        Initializes a custom type from detailed specification

        :type   jsonNode:   dict
        :param  jsonNode:   JSON node for custom type details
        """
        assert isinstance(jsonNode, dict)
        assert "name" in jsonNode and "fields" in jsonNode
        self._standard = False
        self._name = Name(jsonNode["name"])
        self._fields = []
        nodeFields = jsonNode["fields"]
        assert isinstance(nodeFields, list)
        for field in nodeFields:
            assert isinstance(field, dict)
            assert "name" in field and "baseType" in field
            fieldName = Name(field["name"])
            fieldType = BaseType(field["baseType"])
            pair = fieldName, fieldType
            self._fields.append(pair)
        BaseType._typeTable[self._name.asciiValue()] = self

    def __init__from_string(self, name):
        """
        Initializes a standard type by its name

        :type   name:   str
        :param  name:   a value in ["int", "double", "string", "bool", "char"]
        """
        assert isinstance(name, str) or isinstance(name, unicode)
        if name in BaseType._typeTable:
            existingType = BaseType._typeTable[name]
            assert isinstance(existingType, BaseType)
            self._name = copy.deepcopy(existingType._name)
            self._fields = copy.deepcopy(existingType._fields)
            self._standard = existingType._standard
        else:
            self._standard = True
            self._fields = []
            qualifiedName = dict()
            qualifiedName["ascii"] = name
            if name == "int":
                qualifiedName["ru_RU"] = u"цел"
            elif name == "double":
                qualifiedName["ru_RU"] = u"вещ"
            elif name == "bool":
                qualifiedName["ru_RU"] = u"лог"
            elif name == "char":
                qualifiedName["ru_RU"] = u"сим"
            elif name == "string":
                qualifiedName["ru_RU"] = u"лит"
            self._name = Name(qualifiedName)
            BaseType._typeTable[self._name.asciiValue()] = self

    def isStandardType(self):
        """
        Is a standard Qt base type

        :rtype:     bool
        :return:    True, if int, double, bool, char or string
        """
        return self._standard

    def kumirName(self):
        """
        Kumir name for the type

        :rtype:     unicode
        :return:    russian type name
        """
        return self._name.kumirValue()

    def qtName(self):
        """
        Qt-style type name

        :rtype:     str
        :return:    ASCII name matched to Qt/C++ type
        """
        if not self._standard:
            return self._name.cppCamelCaseValue()
        elif self._name.asciiValue() == "string":
            return "QString"
        elif self._name.asciiValue() == "char":
            return "QChar"
        elif self._name.asciiValue() == "double":
            return "qreal"
        else:
            return self._name.asciiValue()

    def cppDeclaration(self):
        """
        For non-standard types creates type declaration or an empty string

        :rtype:     str
        :return:    an empty string for standard type or a struct declaraion otherwise
        """
        if self._standard:
            return ""
        else:
            nameDecl = self.qtName()
            fieldsDecl = ""
            for name, baseType in self._fields:
                assert isinstance(name, Name)
                assert isinstance(baseType, BaseType)
                fieldsDecl += "    "
                fieldsDecl += baseType.qtName() + " "
                fieldsDecl += name.cppValue() + ";"
                fieldsDecl += "\n"
            return _renderTemplate("""
struct $name {
$fields
};
            """, {"name": nameDecl, "fields": fieldsDecl})

    def cppCustomTypeCreation(self, variableToAppend):
        """
        For non-standard types creates kumir type declaration, an empty string otherwise

        :type variableToAppend:     str
        :param variableToAppend:    C++ variable name (std::list or QList) to store result
        :rtype:     unicode
        :return:    an empty string for standard type or Shared::ActorInterface::CustomType implementation code
        """
        if self._standard:
            return ""
        else:
            assert isinstance(variableToAppend, str)
            result = "{\n"
            result += "    Shared::ActorInterface::CustomType custom;\n"
            result += "    Shared::ActorInterface::Record record;\n"
            for fieldName, fieldType in self._fields:
                assert isinstance(fieldName, Name)
                assert isinstance(fieldType, BaseType)
                assert fieldType.qtName() in ["int", "qreal", "bool", "QChar", "QString"]
                name = fieldName.kumirValue()
                typee = fieldType.qtName()
                if typee[0].lower() == 'q':
                    typee = typee[1:]
                typee = typee[0].upper() + typee[1:]
                result += "    record.push_back(Field(QString::fromUtf8(\"%s\"), %s));\n" % (name, typee)
            typeName = self._name.kumirValue()
            result += "    custom = Shared::ActorInterface::CustomType(QString::fromUtf8(\"%s\"), record);\n" % typeName
            result += "    %s.push_back(custom);\n" % variableToAppend
            result += "}\n"
            return result

    def cppCustomTypeInlineEncodeDecode(self):
        """
        Generates encode/decode to/from QVariant inline functions for custom type methods

        :rtype:     str
        :return:    functions C++ inline body for custom type or empty string for standard string
        """
        if self._standard:
            return ""
        else:
            bodyEncode = ""
            bodyDecode = ""
            for index, (fieldName, fieldType) in enumerate(self._fields):
                assert isinstance(fieldName, Name)
                assert isinstance(fieldType, BaseType)
                assert fieldType.qtName() in ["int", "qreal", "bool", "QChar", "QString"]
                typee = fieldType.qtName()
                defvalue = ""
                if typee[0] == 'Q':
                    conversion = "to" + typee[1].upper() + typee[2:] + "()"
                    defvalue = typee + "()"
                elif typee == "qreal":
                    conversion = "toDouble()"
                    defvalue = "0.0"
                else:
                    conversion = "to" + typee[0:].upper() + typee[1:] + "()"
                if not defvalue:
                    if typee == "int":
                        defvalue = "0"
                    elif typee == "bool":
                        defvalue = "false"
                field = fieldName.cppValue()
                bodyEncode += "    result << QVariant(record.%s);\n" % field
                bodyDecode += "    result.%s = alist.size() > %i ? alist.at(%i).%s : %s;\n" % (
                    field, index, index, conversion, defvalue
                )
            substitutions = {
                "typeName": self.qtName(),
                "bodyEncode": bodyEncode,
                "bodyDecode": bodyDecode
            }
            return _renderTemplate("""
inline QVariant encode(const $typeName & record) {
    QVariantList result;
$bodyEncode
    return result;
}

inline $typeName decode(const QVariant & raw) {
    $typeName result;
    const QVariantList alist = raw.toList();
$bodyDecode
    return result;
}
            """, substitutions)


class Argument:
    """
    An actor method argument
    """

    def __init__(self, jsonNode):
        """
        Initializes from JSON node value

        :type   jsonNode:   dict
        :param  jsonNode:   an argument specification
        """
        assert isinstance(jsonNode, dict)
        self.name = Name(jsonNode["name"])
        self.baseType = BaseType(jsonNode["baseType"])
        self.dimension = 0
        if "dim" in jsonNode:
            self.dimension = int(jsonNode["dim"])
        assert 0 <= self.dimension <= 3
        if "access" in jsonNode:
            self.constant = jsonNode["access"] in ["in"]
            self.reference = jsonNode["access"] in ["out", "in/out"]
            self.readable = jsonNode["access"] in ["in", "in/out"]
        else:
            self.constant = True
            self.reference = False
            self.readable = True

    def _makeVectorType(self):
        """
        Creates Qt-vector type declaration

        :rtype:     str
        :return:    C++ argument declaration
        """
        baseType = self.baseType.qtName()
        dimension = self.dimension
        assert isinstance(baseType, str)
        assert isinstance(dimension, int)
        assert 0 < dimension <= 3
        result = "QVector< " * dimension + baseType + " >" * dimension
        return result

    def cppArgumentDeclaration(self):
        """
        Creates C++ function argument declaration

        :rtype:     str
        :return:    C++ argument declaration
        """
        result = ""
        if self.constant:
            result += "const "
        if self.dimension > 0:
            result += self._makeVectorType()
        else:
            result += self.baseType.qtName()
        if self.dimension > 0 or not self.baseType.qtName() in ["int", "qreal", "bool"] or self.reference:
            result += "&"
        result += " " + self.name.cppValue()
        return result

    def cppLocalVariableDeclaration(self):
        """
        Creates C++ local variable declaration

        :rtype:     str
        :return:    C++ plain variable declaration
        """
        result = ""
        if self.dimension > 0:
            result += self._makeVectorType()
        else:
            result += self.baseType.qtName()
        result += " " + self.name.cppValue()
        return result

    def kumirArgumentDeclaration(self):
        """
        Creates Kumir argument declaration

        :rtype:     unicode
        :return:    Kumir argument declaraion
        """
        result = ""
        if self.constant and not self.readable:
            result += u"арг "
        elif self.readable and self.reference:
            result += u"аргрез "
        elif self.reference:
            result += u"рез "
        result += self.baseType.kumirName()
        if self.dimension > 0:
            result += u"таб"
        result += " " + self.name.kumirValue()
        if self.dimension > 0:
            result += "[" + "0:0," * (self.dimension - 1) + "0:0]"
        return result


class Method:
    """
    An actor static method
    """

    _methodTable = list()

    def __init__(self, jsonNode):
        assert isinstance(jsonNode, dict)
        self.name = Name(jsonNode["name"])
        if "returnType" in jsonNode:
            self.returnType = BaseType(jsonNode["returnType"])
        else:
            self.returnType = None
        if "async" in jsonNode:
            self.async = bool(jsonNode["async"])
        else:
            self.async = self.returnType is None
        self.arguments = []
        if "arguments" in jsonNode:
            for arg in jsonNode["arguments"]:
                assert isinstance(arg, dict)
                argument = Argument(arg)
                self.arguments.append(argument)
        if not self in Method._methodTable:
            Method._methodTable.append(self)

    def indexInTable(self):
        """
        Returns an index of this method in table

        :rtype:     int
        :return:    method index
        """
        assert self in Method._methodTable
        return Method._methodTable.index(self)

    def cppDeclaration(self):
        """
        C++ method declaraion

        rtype:      str
        return:     C++ header declaration for this method
        """
        result = ""
        if self.returnType is None:
            result += "void "
        else:
            rtype = self.returnType
            assert isinstance(rtype, BaseType)
            result += rtype.qtName() + " "
        argDeclarations = map(lambda x: x.cppArgumentDeclaration(), self.arguments)
        result += "run" + self.name.cppCamelCaseValue() + "(" + string.join(argDeclarations, ", ") + ")"
        return result

    def kumirDeclaration(self):
        """
        Kumir method declaration

        rtype:      unicode
        return:     Kumir header to be parsed by Kumir analizer as text program
        """
        result = u"алг "
        if not self.returnType is None:
            rtype = self.returnType
            assert isinstance(rtype, BaseType)
            result += rtype.kumirName() + " "
        result += self.name.kumirValue()
        if self.arguments:
            argDeclarations = map(lambda x: x.kumirArgumentDeclaration(), self.arguments)
            result += "(" + string.join(argDeclarations, ", ") + ")"
        return result

    def cppImplementationStub(self, className):
        """
        Creates default method implementation stub

        :type className:    str
        :param className:   module class name used in C++ before ::
        :rtype:             unicode
        :return:            C++ implementation stub
        """
        kumirRtype = ""
        retval = None
        result = "/* public slot */ "
        if not self.returnType is None:
            kumirRtype = self.returnType.kumirName() + " "
            if self.returnType.qtName() == "qreal":
                retval = "0.0"
            elif self.returnType.qtName() == "int":
                retval = "0"
            elif self.returnType.qtName() == "bool":
                retval = "false"
            else:
                retval = self.returnType.qtName() + "()"
        if self.returnType is None:
            result += "void "
        else:
            result += self.returnType.qtName() + " "
        result += className + "::run" + self.name.cppCamelCaseValue()
        body = u"/* алг " + kumirRtype + self.name.kumirValue()
        if self.arguments:
            body += "("
            for index, argument in enumerate(self.arguments):
                assert isinstance(argument, Argument)
                if index:
                    body += ", "
                body += argument.kumirArgumentDeclaration()
            body += ")"
        body += " */\n"
        body += "// TODO implement me\n"
        if not self.arguments:
            result += "()\n"
        else:
            result += "("
            for argument in self.arguments:
                assert isinstance(argument, Argument)
                argumentLine = argument.cppArgumentDeclaration()
                if argument != self.arguments[-1]:
                    argumentLine += ", "
                else:
                    argumentLine += ")"
                result += argumentLine
                body += "Q_UNUSED(" + argument.name.cppValue() + ")  // Remove this line on implementation;\n"
            result += "\n"
        if retval:
            body += "return " + retval + ";\n"
        result += "{\n" + _addIndent(body) + "\n}\n\n"
        return result


class Window:
    """
    A windows of GUI part.
    """

    def __init__(self, jsonNode):
        """
        Initializes from JSON value

        :type   jsonNode:   dict
        :param  jsonNode:   window specification
        """
        assert isinstance(jsonNode, dict)
        self.role = str(jsonNode["role"])
        self.icon = str(jsonNode["icon"])


class MenuItem:
    """
    An item of GUI menu.
    """

    def __init__(self, jsonNode):
        """
        Initializes from JSON value

        :type   jsonNode:   dict
        :param  jsonNode:   menu item specification
        """
        assert isinstance(jsonNode, dict)
        assert "title" in jsonNode
        self.title = Name(jsonNode["title"])
        self.items = []
        if "items" in jsonNode:
            for item in jsonNode["items"]:
                self.items.append(MenuItem(item))
        if "icon" in jsonNode:
            self.icon = str(jsonNode["icon"])
        else:
            self.icon = None


class Gui:
    """
    GUI part of module.
    """

    def __init__(self, jsonNode):
        """
        Initializes from JSON value

        :type   jsonNode:   dict
        :param  jsonNode:   GUI specification
        """
        assert isinstance(jsonNode, dict)
        self.windows = []
        self.menus = []
        if "windows" in jsonNode:
            for window in jsonNode["windows"]:
                self.windows.append(Window(window))
        if "menus" in jsonNode:
            for menu in jsonNode["menus"]:
                self.menus.append(MenuItem(menu))

    def iconName(self, role):
        """
        Icon name for specified window role

        :type role:     str
        :param role:    role of window (currently "main" and "pult")
        :rtype:         str
        :return:        icon base name of an empty string if not specified
        """
        for window in self.windows:
            assert isinstance(window, Window)
            if window.role == role and window.icon:
                return window.icon
        return ""


class Module:
    """
    A Kumir module.
    """

    def __init__(self, jsonNode):
        """
        Initializes from JSON value

        :type   jsonNode:   dict
        :param  jsonNode:   Module specification (JSON root)
        """
        assert isinstance(jsonNode, dict)
        assert "name" in jsonNode
        assert "methods" in jsonNode
        self.name = Name(jsonNode["name"])
        self.types = []
        if "types" in jsonNode:
            for typee in jsonNode["types"]:
                self.types.append(BaseType(typee))
        self.methods = []
        for method in jsonNode["methods"]:
            self.methods.append(Method(method))
        if "gui" in jsonNode:
            self.gui = Gui(jsonNode["gui"])
        else:
            self.gui = None
        if "settings" in jsonNode:
            self.settings = Settings(jsonNode["settings"])
        else:
            self.settings = None

    @classmethod
    def read(cls, fileName):
        """
        Reads module definition from JSON file

        :type fileName:     unicode
        :param fileName:    a file name to read from
        :rtype:             Module
        :return:            Kumir module object
        """
        f = open(fileName, 'r')
        data = json.load(f, "utf-8")
        f.close()
        return Module(data)

    def className(self):
        """
        Module class name to be implemented by developer

        :rtype:     str
        :return:    class name
        """
        return self.name.cppCamelCaseValue() + MODULE_CLASS_SUFFIX

    def baseClassName(self):
        """
        Base module class name generated and updated by script

        :rtype:     str
        :return:    class name
        """
        return self.name.cppCamelCaseValue() + MODULE_BASE_CLASS_SUFFIX

    def pluginClassName(self):
        """
        Plugin class name generated and updated by script

        :rtype:     str
        :return:    class name
        """
        return self.name.cppCamelCaseValue() + MODULE_PLUGIN_CLASS_SUFFIX

    def runThreadClassName(self):
        """
        Class name for asynchronuous thread

        :rtype:     str
        :return:    class name
        """
        return self.name.cppCamelCaseValue() + MODULE_RUN_THREAD_SUFFIX

    def namespace(self):
        """
        Module namespace

        :rtype:     str
        :return:    namespace
        """
        return MODULE_NAMESPACE_PREFIX + self.name.cppCamelCaseValue()


class SettingsEntry:
    """
    An entry for actor settings page
    """
    def __init__(self, key, jsonEntry):
        """
        Initializes from JSON value

        :type   key:        str
        :param  key:        an unique settings key string
        :type   jsonEntry:  dict
        :param  jsonEntry:  settings entry specification
        """
        assert isinstance(key, str) or isinstance(key, unicode)
        assert isinstance(jsonEntry, dict)
        self._key = key
        self._type = jsonEntry["type"]
        self._default = jsonEntry["default"]
        if "minimum" in jsonEntry:
            self._minimum = jsonEntry["minimum"]
        else:
            self._minimum = None
        if "maximum" in jsonEntry:
            self._maximum = jsonEntry["maximum"]
        else:
            self._maximum = None
        self._title = Name(jsonEntry["title"])

    def cppEntryImplementation(self, mapToAdd):
        """
        Creates C++ implementation for creation of settings entry

        :type   mapToAdd:   str
        :param  mapToAdd:   C++ valid name of variable of type QMap<QString,Entry> to store result
        :rtype:             unicode
        :return:            C++ code for settings entry creation
        """
        assert isinstance(mapToAdd, str)
        if "ru_RU" in self._title.data:
            title = self._title.data["ru_RU"]
        else:
            title = self._title.data["ascii"]
        Types = {
            "int": "Integer",
            "double": "Double",
            "string": "String",
            "char": "Char",
            "bool": "Bool",
            "color": "Color",
            "font": "Font"
        }
        typee = Types[self._type]
        if typee in ["String", "Color", "Font"]:
            default = "QString::fromUtf8(\"%s\")" % unicode(self._default)
        else:
            default = unicode(self._default)
        if self._minimum is None:
            minimum = "QVariant::Invalid"
        else:
            minimum = unicode(self._minimum)
        if self._maximum is None:
            maximum = "QVariant::Invalid"
        else:
            maximum = unicode(self._maximum)
        return """
{
    ExtensionSystem::DeclarativeSettingsPage::Entry entry;
    entry.title = QString::fromUtf8("%s");  // TODO non-Russian language support
    entry.type = ExtensionSystem::DeclarativeSettingsPage::%s;
    entry.defaultValue = %s;
    entry.minimumValue = %s;
    entry.maximumValue = %s;
    %s["%s"] = entry;
}
        """ % (title, typee, default, minimum, maximum, mapToAdd, self._key)


class Settings:
    """
    Settings entries specification
    """
    def __init__(self, jsonNode):
        """
        Initializes from JSON node

        :type   jsonNode:   dict
        :param  jsonNode:   settings specification
        """
        assert isinstance(jsonNode, dict)
        self._entries = []
        for key, value in jsonNode.items():
            self._entries.append(SettingsEntry(key, value))

    def createSettingsPage(self, variableName, actorAsciiName):
        """
        Creates a C++ code for settings page creation

        :type   variableName:   str
        :param  variableName:   DeclarativeSettingsPage* type C++ variable name to store
        :type   actorAsciiName: str
        :param  actorAsciiName: ASCII actor name used to create settings page
        :rtype:                 unicode
        :return:                C++ code for settings page creation
        """
        result = "QMap<QString,ExtensionSystem::DeclarativeSettingsPage::Entry> entries;\n"
        for entry in self._entries:
            assert isinstance(entry, SettingsEntry)
            result += entry.cppEntryImplementation("entries")
        result += """
%s = new ExtensionSystem::DeclarativeSettingsPage(
                            "%s",
                            name(),
                            mySettings(),
                            entries
                          );

        """ % (variableName, actorAsciiName)
        return result


# The group of classes to generate sources

class CppClassBase:
    """
    Base class for C++ class implementation.

    The derived classes implements methods with suffix "CppImplementation", while base class
    functionality is to introspect derived class structure and generate corresponding header
    and source file data

    """

    def __init__(self):
        """
        Field initialization
        """
        self.className = None
        self.classDeclarationPrefix = ""
        self.classDeclarationSuffix = ""
        self.fields = []
        self.signals = []
        self.baseClasses = []
        self.abstractPublicMethods = []
        self.abstractPublicSlots = []
        self.extraImplementations = []

    def __implementation_of_method__(self, methodName):
        """
        Calls method implementation creation and returns a result.

        Each implemented C++ method should have corresponding Python method named
        the same + suffix 'CppImplementation'

        :type   methodName: str
        :param  methodName: С++ method name to find an call its Pythonic creator
        :rtype:             unicode
        :return:            C++ code
        """
        assert isinstance(methodName, str)
        pythonMethodName = methodName + "CppImplementation"
        try:
            method = getattr(self, pythonMethodName).__func__
        except AttributeError:
            method = None
        if method:
            return method(self)
        else:
            return ""

    def cppDeclaration(self):
        """
        Generates C++ (with Qt extensions) class declaration for header file

        :rtype:     unicode
        :return:    C++ class declaration
        """
        publics = []
        public_slots = []
        protecteds = []
        protected_slots = []
        privates = []
        private_slots = []
        constructor = None
        nonInspectable = map(lambda x: ("CppImplementation", x), self.extraImplementations)
        for key, value in inspect.getmembers(self) + nonInspectable:
            assert isinstance(key, str)
            if key.endswith("CppImplementation"):
                if isinstance(value, str) or isinstance(value, unicode):
                    implementation = value
                else:
                    implMethod = value.__func__
                    implementation = implMethod(self)
                assert isinstance(implementation, str) or isinstance(implementation, unicode)
                firstLine = implementation.strip().split('\n')[0].strip()
                assert isinstance(firstLine, str) or isinstance(firstLine, unicode)
                if not firstLine:
                    continue  # pure virtual method
                groupEndPos = firstLine.index("*/")
                groupName = firstLine[2:groupEndPos].strip().replace(" ", "_")
                rtypeEndPos = firstLine.index(" ", groupEndPos+3)
                returnType = firstLine[groupEndPos+2:rtypeEndPos].strip()
                signatureBeginPos = firstLine.index("::", rtypeEndPos) + 2
                signature = firstLine[signatureBeginPos:]
                assert groupName in ["public", "protected", "private", "public_slot", "protected_slot", "private_slot"]
                group = locals()[groupName + 's']
                group += [_addIndent(returnType + " " + signature + ";")]
            elif key == "constructorImplementation":
                implMethod = value.__func__
                implementation = implMethod(self)
                assert isinstance(implementation, str) or isinstance(implementation, unicode)
                firstLine = implementation.strip().split('\n')[0].strip()
                assert isinstance(firstLine, str) or isinstance(firstLine, unicode)
                assert "::" in firstLine
                start = firstLine.index("::") + 2
                signature = firstLine[start:].strip()
                publics.insert(0, _addIndent(signature + ";"))
        publics += map(lambda x: _addIndent("virtual " + x + " = 0;"), self.abstractPublicMethods)
        public_slots += map(lambda x: _addIndent("virtual " + x + " = 0;"), self.abstractPublicSlots)
        if publics:
            publics = ["public /* methods */:"] + publics
        if public_slots:
            public_slots = ["public slots:"] + public_slots
        if protecteds:
            protecteds = ["protected /* methods */:"] + protecteds
        if privates:
            privates = ["private /* methods */:"] + privates
        if private_slots:
            private_slots = ["private slots:"] + private_slots
        if self.signals:
            signals = string.join(["signals:"] + map(lambda x: _addIndent(x + ";"), self.signals), '\n')
        else:
            signals = ""
        if self.fields:
            fields = string.join(["protected /* fields */:"] + map(lambda x: _addIndent(x + ";"), self.fields), '\n')
        else:
            fields = ""
        if self.baseClasses:
            baseClasses = "\n    : public " + string.join(self.baseClasses, "\n    , public ")
        else:
            baseClasses = ""
        substitutions = {
            "className": self.className,
            "classDeclarationPrefix": self.classDeclarationPrefix,
            "classDeclarationSuffix": self.classDeclarationSuffix,
            "baseClasses": baseClasses,
            "publicMethods": string.join(publics, "\n"),
            "publicSlots": string.join(public_slots, "\n"),
            "protectedMethods": string.join(protecteds, "\n"),
            "privateMethods": string.join(privates, "\n"),
            "protectedSlots": string.join(protected_slots, "\n"),
            "privateSlots": string.join(private_slots, "\n"),
            "privateFields": fields,
            "signals": signals
        }
        return _renderTemplate("""
class $className$baseClasses
{
$classDeclarationPrefix
$publicMethods
$publicSlots
$signals


    /* ========= CLASS PRIVATE ========= */
$protectedMethods
$privateMethods
$protectedSlots
$privateSlots
$privateFields
$classDeclarationSuffix
};
        """, substitutions)

    def cppImplementation(self):
        """
        Generates complete C++ class implementation for all the methods

        :rtype:     unicode
        :return:    C++ class implementation code
        """
        result = ""
        nonInspectable = map(lambda x: ("CppImplementation", x), self.extraImplementations)
        for key, value in inspect.getmembers(self) + nonInspectable:
            assert isinstance(key, str)
            if key.endswith("CppImplementation") or key == "constructorImplementation":
                if isinstance(value, str) or isinstance(value, unicode):
                    implementation = value
                else:
                    implMethod = value.__func__
                    implementation = implMethod(self)
                assert isinstance(implementation, str) or isinstance(implementation, unicode)
                if key == "constructorImplementation":
                    result = implementation.strip() + "\n\n" + result
                else:
                    result += implementation.strip() + "\n\n"
        return result


class PluginCppClass(CppClassBase):
    """
    C++ Qt Plugin class.
    """

    def __init__(self, module):
        """
        Initializes from actor module tree

        :type   module: Module
        :param  module: actor module root
        """
        CppClassBase.__init__(self)
        assert isinstance(module, Module)
        self._module = module
        self.className = module.pluginClassName()
        self.baseClasses = [
            "ExtensionSystem::KPlugin",
            "Shared::ActorInterface"
        ]
        self.fields = [
            "class %s* module_" % module.baseClassName(),
            "class %s* asyncRunThread_" % module.runThreadClassName(),
            "class ExtensionSystem::DeclarativeSettingsPage* settingsPage_",
            "QString errorText_",
            "QVariant result_",
            "QVariantList optResults_"
        ]
        self.signals = ["void sync()"]
        self.classDeclarationPrefix = """
    friend class %s;
    friend class %s;
    Q_OBJECT
    Q_INTERFACES(Shared::ActorInterface)
        """ % (self._module.runThreadClassName(), self._module.baseClassName())
        self.classDeclarationSuffix = """
private:
    template <typename T> inline static QVector<T> toVector1(const QVariant & v)
    {
        const QVariantList l = v.toList();
        QVector<T> result;
        result.resize(l.size());
        for (int i=0; i<l.size(); i++) {
            result[i] = qvariant_cast<T>(l[i]);
        }
        return result;
    }
    template <typename T> inline static QVector< QVector<T> > toVector2(const QVariant & v)
    {
        const QVariantList l = v.toList();
        QVector< QVector<T> > result;
        result.resize(l.size());
        for (int i=0; i<l.size(); i++) {
            const QVariantList ll = l[i].toList();
            result[i].resize(ll.size());
            for (int j=0; j<ll.size(); j++) {
                result[i][j] = qvariant_cast<T>(ll[j]);
            }
        }
        return result;
    }
    template <typename T> inline static QVector< QVector< QVector<T> > > toVector3(const QVariant & v)
    {
        const QVariantList l = v.toList();
        QVector< QVector< QVector<T> > > result;
        result.resize(l.size());
        for (int i=0; i<l.size(); i++) {
            const QVariantList ll = l[i].toList();
            result[i].resize(ll.size());
            for (int j=0; j<ll.size(); j++) {
                const QVariantList lll = ll[j].toList();
                result[i][j].resize(lll.size());
                for (int k=0; k<lll.size(); k++) {
                    result[i][j][k] = qvariant_cast<T>(lll[k]);
                }
            }
        }
        return result;
    }
        """

    def constructorImplementation(self):
        """
        Returns implementation of class constructor

        :rtype:     unicode
        :return:    C++ constructor code
        """
        return """
%s::%s()
    : ExtensionSystem::KPlugin()
    , module_(nullptr)
    , asyncRunThread_(nullptr)
    , settingsPage_(nullptr)
{
}
        """ % (self.className, self.className)

    def isGuiRequiredCppImplementation(self):
        """
        Creates implementation of isGuiRequired

        :rtype:     str
        :return:    implementation of bool isGuiRequired() const
        """
        if self._module.gui:
            guiRequired = "true"
        else:
            guiRequired = "false"
        return """
/* public */ bool %s::isGuiRequired() const
{
    return %s;
}
        """ % (self.className, guiRequired)

    def nameCppImplementation(self):
        """
        Creates implementation of name

        :rtype:     unicode
        :return:    implementation of QString name() const
        """
        # TODO non-Russian language implementation
        body = "return QString::fromUtf8(\"%s\");" % self._module.name.kumirValue()
        return """
/* public */ QString %s::name() const
{
%s
}
        """ % (self.className, _addIndent(body))

    def funcListCppImplementation(self):
        """
        Creates implementation of funcList

        :rtype:     unicode
        :return:    implementation of QStringList funcList() const
        """
        methods = self._module.methods
        lines = map(lambda x: "result << QString::fromUtf8(\"" + x.kumirDeclaration() + "\");", methods)
        body = _addIndent(string.join(lines, '\n'))
        return """
/* public */ QStringList %s::funcList() const
{
    QStringList result;
%s;
    return result;
}
        """ % (self.className, body)

    def typeListCppImplementation(self):
        """
        Creates implementation of typeList

        :rtype:     unicode
        :return:    implementation of TypeList typeList() const
        """
        body = ""
        if self._module.types:
            body += """
        """
            for typee in self._module.types:
                assert isinstance(typee, BaseType)
                if typee.cppCustomTypeCreation("result"):
                    body += typee.cppCustomTypeCreation("result")
        return """
/* public */ Shared::ActorInterface::TypeList %s::typeList() const
{
    Shared::ActorInterface::TypeList result;
%s
    return result;
}
        """ % (self.className, _addIndent(body))

    def customValueToStringCppImplementation(self):
        """
        Creates implementation of customValueToString

        :rtype:     unicode
        :return:    implementation of QString customValueToString(const CustomType &, const QVariant &) const
        """
        body = ""
        clazz = ""
        value = ""
        for method in self._module.methods:
            assert isinstance(method, Method)
            if method.name.asciiValue() == "output":
                clazz = "clazz"
                value = "value"
                assert len(method.arguments) == 1
                argument = method.arguments[0]
                assert isinstance(argument, Argument)
                assert not argument.baseType.isStandardType()
                if body:
                    body += "    else "
                body += "    if (clazz.first==QString::fromUtf8(\"%s\")) {\n" % argument.baseType.kumirName()
                body += "        %s x = decode(value);\n" % argument.baseType.qtName()
                body += "        result = module_->runOperatorOUTPUT(x);\n    }\n"
        return """
/* public */ QString %s::customValueToString(const CustomType & %s, const QVariant %s) const
{
    QString result;
%s
    return result;
}
        """ % (self.className, clazz, value, body)

    def customValueFromStringCppImplementation(self):
        """
        Creates implementation of customValueFromString

        :rtype:     unicode
        :return:    implementation of QVariant customValueFromString(const CustomType &, const QString &) const
        """
        body = ""
        clazz = ""
        stringg = ""
        for method in self._module.methods:
            assert isinstance(method, Method)
            if method.name.asciiValue() == "input":
                clazz = "clazz"
                stringg = "stringg"
                rtype = method.returnType
                assert isinstance(rtype, BaseType)
                assert len(method.arguments) == 2
                argument = method.arguments[0]
                assert isinstance(argument, Argument)
                assert argument.baseType.qtName() == "QString"
                if body:
                    body += "    else "
                body += "    if (clazz.first==QString::fromUtf8(\"%s\")) {\n" % rtype.kumirName()
                body += "        %s x; bool ok = false;\n" % rtype.qtName()
                body += "        x = module_->runOperatorINPUT(stringg, ok);\n"
                body += "        if (ok) {\n"
                body += "            result = encode(x);\n"
                body += "        }\n"
                body += "    }\n"
        return """
/* public */ QVariant %s::customValueFromString(const CustomType & %s, const QString %s) const
{
    QVariant result;
%s
    return result;
}
        """ % (self.className, clazz, stringg, body)

    def mainIconNameCppImplementation(self):
        """
        Creates mainIconName C++ implementation

        :rtype:     str
        :return:    implementation of QString mainIconName() const
        """
        iconName = ""
        if self._module.gui:
            gui = self._module.gui
            assert isinstance(gui, Gui)
            iconName = gui.iconName("main")
        return """
/* public */ QString %s::mainIconName() const
{
    return QString::fromAscii(\"%s\");
}
        """ % (self.className, iconName)

    def pultIconNameCppImplementation(self):
        """
        Creates pultIconName C++ implementation

        :rtype:     str
        :return:    implementation of QString pultIconName() const
        """
        iconName = ""
        if self._module.gui:
            gui = self._module.gui
            assert isinstance(gui, Gui)
            iconName = gui.iconName("pult")
        return """
/* public */ QString %s::pultIconName() const
{
    return QString::fromAscii(\"%s\");
}
        """ % (self.className, iconName)

    def mainWidgetCppImplementation(self):
        """
        Creates mainWidget C++ implementation

        :rtype:     str
        :return:    implementation of QWidget* mainWidget()
        """
        return """
/* public */ QWidget* %s::mainWidget()
{
    return module_->mainWidget();
}
        """ % self.className

    def pultWidgetCppImplementation(self):
        """
        Creates pultWidget C++ implementation

        :rtype:     str
        :return:    implementation of QWidget* pultWidget()
        """
        return """
/* public */ QWidget* %s::pultWidget()
{
    return module_->pultWidget();
}
        """ % self.className

    def moduleMenusCppImplementation(self):
        """
        Creates moduleMenus C++ implementation

        :rtype:     str
        :return:    implementation of QList<QMeny*> moduleMenus() const
        """
        return """
/* public */ QList<QMenu*> %s::moduleMenus() const
{
    return module_->moduleMenus();
}
        """ % self.className

    def settingsEditorPageCppImplementation(self):
        """
        Creates settingsEditorPage C++ implementation

        :rtype:     str
        :return:    implementation of QWidget* settingsEditorPage();
        """
        return """
/* public */ QWidget* %s::settingsEditorPage()
{
    return settingsPage_;
}
        """ % self.className

    def resetCppImplementation(self):
        """
        Creates reset C++ implementation

        :rtype:     str
        :return:    implementation of void reset();
        """
        return """
/* public */ void %s::reset()
{
    module_->reset();
}
        """ % self.className

    def setAnimationEnabledCppImplementation(self):
        """
        Creates setAnimationEnabled C++ implementation

        :rtype:     str
        :return:    implementation of void setAnimationEnabled(bool)
        """
        return """
/* public */ void %s::setAnimationEnabled(bool enabled)
{
    // The module might be not created at a time of call,
    // so check it propertly
    if (module_) {
        module_->setAnimationEnabled(enabled);
    }
}
        """ % self.className

    def evaluateCppImplementation(self):
        """
        Creates evaluate C++ implementation

        :rtype:     unicode
        :return:    implementation of EvaluationStatus evaluate(quint32, const QVariantList&)
        """
        switchBody = ""
        for method in self._module.methods:
            assert isinstance(method, Method)
            switchBody += "case 0x%04x: {\n" % method.indexInTable()
            switchBody += "    /* %s */\n" % method.name.asciiValue()
            if method.async:
                switchBody += "    asyncRunThread_->init(index, args);\n"
                switchBody += "    asyncRunThread_->start();\n"
                switchBody += "    return ES_Async;\n"
            else:
                args = []
                for index, argument in enumerate(method.arguments):
                    assert isinstance(argument, Argument)
                    switchBody += "    %s = " % argument.cppLocalVariableDeclaration()
                    if argument.dimension > 0:
                        switchBody += "toVector%d<%s>(args[%d])" % (
                            argument.dimension,
                            argument.baseType.qtName(),
                            index
                        )
                    elif argument.baseType.qtName() in ["int", "qreal", "bool", "QString", "QChar"]:
                        switchBody += "qvariant_cast<%s>(args[%d])" % (argument.baseType.qtName(), index)
                    else:
                        switchBody += "decode(args[%d])" % index
                    switchBody += ";\n"
                    args += [argument.name.cppValue()]
                if method.returnType:
                    returnType = method.returnType
                    assert isinstance(returnType, BaseType)
                    switchBody += "    result_ = "
                    if returnType.qtName() in ["int", "qreal", "bool", "QString", "QChar"]:
                        switchBody += "QVariant::fromValue("
                    else:
                        switchBody += "encode("
                else:
                    switchBody += "    "
                switchBody += "module_->run%s(%s)" % (method.name.cppCamelCaseValue(), string.join(args, ", "))
                if method.returnType:
                    switchBody += ");\n"
                else:
                    switchBody += ";\n"
                returnsAnyArgument = False
                for argument in method.arguments:
                    assert isinstance(argument, Argument)
                    switchBody += "    optResults_ << "
                    if argument.reference and not argument.constant:
                        returnsAnyArgument = True
                        plainType = argument.baseType.qtName() in ["int", "qreal", "bool", "QString", "QChar"]
                        if plainType or argument.dimension > 0:
                            switchBody += "QVariant::fromValue(%s);\n" % argument.name.cppValue()
                        else:
                            switchBody += "encode(%s);\n" % argument.name.cppValue()
                    else:
                        switchBody += "QVariant::Invalid;\n"
                switchBody += "    if (errorText_.length() > 0) {\n"
                switchBody += "        return ES_Error;\n"
                switchBody += "    }\n"
                if returnsAnyArgument and method.returnType:
                    switchBody += "    return ES_StackRezResult;\n"
                elif returnsAnyArgument:
                    switchBody += "    return ES_RezResult;\n"
                elif method.returnType:
                    switchBody += "    return ES_StackResult;\n"
                else:
                    switchBody += "    return ES_NoResult;\n"
            switchBody += "    break;\n"
            switchBody += "}\n\n"

        return """
/* public */ Shared::EvaluationStatus %s::evaluate(quint32 index, const QVariantList & args)
{
    using namespace Shared;
    errorText_.clear();
    result_ = QVariant::Invalid;
    optResults_.clear();
    switch (index) {
%s
        default : {
            errorText_ = "Unknown method index";
            return ES_Error;
        }
    }
}
        """ % (self.className, _addIndent(_addIndent(switchBody)))

    def resultCppImplementation(self):
        """
        Creates result C++ implementation

        :rtype:     str
        :return:    implementation of QVariant result() const
        """
        return """
/* public */ QVariant %s::result() const
{
    return result_;
}
        """ % self.className

    def algOptResultsCppImplementation(self):
        """
        Creates algOptResult C++ implementation

        :rtype:     str
        :return:    implementation of QVariantList algOptResults() const
        """
        return """
/* public */ QVariantList %s::algOptResults() const
{
    return optResults_;
}
        """ % self.className

    def errorTextCppImplementation(self):
        """
        Creates errorText C++ implementation

        :rtype:     str
        :return:    implementation of QString errorText() const
        """
        return """
/* public */ QString %s::errorText() const
{
    return errorText_;
}
        """ % self.className

    def connectSyncCppImplementation(self):
        """
        Creates connectSync C++ implementation

        :rtype:     str
        :return:    implementation of void connectSync(QObject*, const char*)
        """
        return """
/* public */ void %s::connectSync(QObject* receiver, const char* method)
{
    QObject::connect(this, SIGNAL(sync()), receiver, method, Qt::DirectConnection);
}
        """ % self.className

    def initializeCppImplementation(self):
        """
        Creates initialize C++ implementation

        :rtype:     str
        :return:    implementation of QString initialize(const QStringList&)
        """
        body = "module_ = new %s(this);\n" % self._module.className()
        methods = self._module.methods
        asyncMethods = filter(lambda method: method.async, methods)
        if self._module.settings:
            moduleName = self._module.name.cppCamelCaseValue()
            body += self._module.settings.createSettingsPage("settingsPage_", moduleName).strip() + "\n\n"

        if asyncMethods:
            body += "asyncRunThread_ = new %s(this, module_);\n" % self._module.runThreadClassName()
            body += "QObject::connect(asyncRunThread_, SIGNAL(finished()),\n"
            body += "                 this, SIGNAL(sync()));\n"
        body += "return QString();\n"
        return """
/* protected */ QString %s::initialize(const QStringList &)
{
%s
}
        """ % (self.className, _addIndent(body))

    def sleepCppImplementation(self):
        """
        Creates sleep implementation

        :rtype:     str
        :return:    implementation of void sleep(unsigned long)
        """
        return """
/* protected */ void %s::sleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->asleep(secs);
    }
}
        """ % self.className

    def msleepCppImplementation(self):
        """
        Creates msleep implementation

        :rtype:     str
        :return:    implementation of void msleep(unsigned long)
        """
        return """
/* protected */ void %s::msleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->amsleep(secs);
    }
}
        """ % self.className

    def usleepCppImplementation(self):
        """
        Creates usleep implementation

        :rtype:     str
        :return:    implementation of void usleep(unsigned long)
        """
        return """
/* protected */ void %s::usleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->ausleep(secs);
    }
}
        """ % self.className

    def changeGlobalStateCppImplementation(self):
        """
        Creates changeGlobalState implementation

        :rtype:     str
        :return:    implementation of void changeGlobalState(GlobalState, GlobalState)
        """
        return """
/* protected */ void %s::changeGlobalState(ExtensionSystem::GlobalState old, ExtensionSystem::GlobalState current)
{
    module_->changeGlobalState(old, current);
}
        """ % self.className

    def handleSettingsChangedCppImplementation(self):
        """
        Creates handleSettingsChanged implementation

        :rtype:     str
        :return:    implementation of void handleSettingsChanged()
        """
        return """
/* private slot */ void %s::handleSettingsChangedCppImplementation()
{
    if (module_) {
        module_->reloadSettings(mySettings());
    }
}
        """ % self.className

    def updateSettingsCppImplementation(self):
        """
        Creates updateSettings implementation

        :rtype:     str
        :return:    implementation of void updateSettings()
        """
        return """
/* private */ void %s::updateSettings()
{
    if (settingsPage_) {
        settingsPage_->setSettingsObject(mySettings());
    }
    if (module_) {
        module_->reloadSettings(mySettings());
    }
}
        """ % self.className


class AsyncThreadCppClass(CppClassBase):
    """
    Class for asynchronous method evaluation in separate thread
    """
    def __init__(self, module):
        """
        Initializes from actor module tree
        """
        CppClassBase.__init__(self)
        assert isinstance(module, Module)
        self._module = module
        self.className = module.runThreadClassName()
        self.fields = [
            "quint32 index_",
            "QVariantList args_",
            "class %s* plugin_" % module.pluginClassName(),
            "class %s* module_" % module.baseClassName()
        ]
        self.baseClasses = ["QThread"]

    def constructorImplementation(self):
        """
        Creates C++ constructor implementation

        :rtype:     str
        :return:    C++ code for constructor implementation
        """
        return """
%s::%s(class %s* plugin, class %s* module)
    : QThread(plugin)
    , index_(0)
    , args_(QVariantList())
    , plugin_(plugin)
    , module_(module)
{
}
        """ % (self.className, self.className, self._module.pluginClassName(), self._module.baseClassName())

    def initCppImplementation(self):
        """
        Creates init implementation

        :rtype:     str
        :return:    implementation of void init(quint32, const QVariantList &)
        """
        return """
/* public */ void %s::init(quint32 index, const QVariantList & args)
{
    index_ = index;
    args_ = args;
}
        """ % self.className

    def asleepCppImplementation(self):
        """
        Creates asleep implementation

        :rtype:     str
        :return:    implementation of void asleep(unsigned long)
        """
        return """
/* public */ void %s::asleep(unsigned long secs)
{
    sleep(secs);
}
        """ % self.className

    def amsleepCppImplementation(self):
        """
        Creates amsleep implementation

        :rtype:     str
        :return:    implementation of void amsleep(unsigned long)
        """
        return """
/* public */ void %s::amsleep(unsigned long secs)
{
    msleep(secs);
}
        """ % self.className

    def ausleepCppImplementation(self):
        """
        Creates ausleep implementation

        :rtype:     str
        :return:    implementation of void ausleep(unsigned long)
        """
        return """
/* public */ void %s::ausleep(unsigned long secs)
{
    usleep(secs);
}
        """ % self.className

    def runCppImplementation(self):
        """
        Creates thread run implementation

        :rtype:     unicode
        :return:    implementation of void run()
        """
        switchBody = ""
        methods = filter(lambda method: method.async, self._module.methods)
        for method in methods:
            assert isinstance(method, Method)
            switchBody += "case 0x%04x: {\n" % method.indexInTable()
            switchBody += "    /* %s */\n" % method.name.asciiValue()
            args = []
            for index, argument in enumerate(method.arguments):
                assert isinstance(argument, Argument)
                args += [argument.name.cppValue()]
                switchBody += "    %s = " % argument.cppLocalVariableDeclaration()
                if argument.dimension > 0:
                    switchBody += "toVector%d<%s>(args[%d])" % (
                        argument.dimension,
                        argument.baseType.qtName(),
                        index
                    )
                elif argument.baseType.qtName() in ["int", "qreal", "bool", "QString", "QChar"]:
                    switchBody += "qvariant_cast<%s>(args_[%d])" % (argument.baseType.qtName(), index)
                else:
                    switchBody += "decode(args_[%d])" % index
                switchBody += ";\n"
            if method.returnType:
                returnType = method.returnType
                assert isinstance(returnType, BaseType)
                switchBody += "    plugin_->result_ = "
                if returnType.qtName() in ["int", "qreal", "bool", "QString", "QChar"]:
                    switchBody += "QVariant::fromValue("
                else:
                    switchBody += "encode("
            else:
                switchBody += "    "
            switchBody += "module_->run%s(%s)" % (method.name.cppCamelCaseValue(), string.join(args, ", "))
            if method.returnType:
                switchBody += ");\n"
            else:
                switchBody += ";\n"
            for argument in method.arguments:
                assert isinstance(argument, Argument)
                switchBody += "    plugin_->optResults_ << "
                if argument.reference and not argument.constant:
                    plainType = argument.baseType.qtName() in ["int", "qreal", "bool", "QString", "QChar"]
                    if plainType or argument.dimension > 0:
                        switchBody += "QVariant::fromValue(%s);\n" % argument.name.cppValue()
                    else:
                        switchBody += "encode(%s);\n" % argument.name.cppValue()
                else:
                    switchBody += "QVariant::Invalid;\n"
            switchBody += "    break;\n"
            switchBody += "}\n"
        return """
/* private */ void %s::run()
{
    switch (index_) {
%s
        default: {
            plugin_->errorText_ = "Unknown method index";
        }
    }
}
        """ % (self.className, _addIndent(_addIndent(switchBody)))


class ModuleBaseCppClass(CppClassBase):
    """
    C++ base class for module implementation
    """
    def __init__(self, module):
        """
        Initializes from actor module tree
        """
        assert isinstance(module, Module)
        CppClassBase.__init__(self)
        self.baseClasses = ["QObject"]
        self._module = module
        self.className = module.baseClassName()
        self.classDeclarationPrefix = "    Q_OBJECT"
        self.abstractPublicSlots = [
            "void reset()",
            "void reloadSettings(QSettings* settings)",
            "void changeGlobalState(ExtensionSystem::GlobalState old, ExtensionSystem::GlobalState current)",
        ]
        if module.gui:
            self.abstractPublicMethods += [
                "QWidget* mainWidget() const",
                "QWidget* pultWidget() const",
            ]
            self.abstractPublicSlots += [
                "void setAnimationEnabled(bool enabled)"
            ]
        for method in module.methods:
            assert isinstance(method, Method)
            self.abstractPublicSlots += [method.cppDeclaration()]
        if module.gui:
            for menu in module.gui.menus:
                self.fields += self._add_menu_actions_as_fields(menu)

    def _add_menu_actions_as_fields(self, menu, parentPrefix="", toplevel=True):
        """
        Walks on menu item tree and yields menu items as QMenu* or QAction* fields

        :type   menu:           MenuItem
        :param  menu:           current top level menu item
        :type   parentPrefix:   str
        :param  parentPrefix:   parent prefix name constructed from top level items
        :type   toplevel:       bool
        :param  toplevel:       True if menu item is a top level
        :rtype:                 list
        :return:                list of field declarations
        """
        assert isinstance(menu, MenuItem)
        result = []
        if toplevel:
            root = "QMenu* m_menu"
        else:
            root = "QAction* m_action"
        root += parentPrefix + menu.title.cppCamelCaseValue()
        result += [root]
        for child in menu.items:
            result += self._add_menu_actions_as_fields(child, parentPrefix + menu.title.cppCamelCaseValue(), False)
        return result

    def _add_menu_actions_creation(self, menu, parentPrefix="", deep=0):
        """
        Walks on menu item tree and yields menu items creation code

        :type   menu:           MenuItem
        :param  menu:           current top level menu item
        :type   parentPrefix:   str
        :param  parentPrefix:   parent prefix name constructed from top level items
        :type   deep:           int
        :param  deep:           the deep of current menu item tree
        :rtype:                 unicode
        :return:                C++ code for menu items creation
        """
        assert isinstance(menu, MenuItem)
        result = ""
        if deep == 0:
            result += "m_menu%s = new QMenu();\n" % menu.title.cppCamelCaseValue()
            setTitle = "m_menu%s->setTitle" % menu.title.cppCamelCaseValue()
        else:
            assert parentPrefix
            if deep == 1:
                parent = "m_menu" + parentPrefix
            else:
                parent = "m_action%s->menu()" % parentPrefix
            result += "m_action%s = %s->addAction(\"\");\n" % (
                parentPrefix + menu.title.cppCamelCaseValue(),
                parent
            )
            setTitle = "m_action%s->setText" % (parentPrefix + menu.title.cppCamelCaseValue())
        asciiName = ""
        otherNames = {}
        for key, value in menu.title.data.items():
            assert isinstance(key, str) or isinstance(key, unicode)
            assert isinstance(value, str) or isinstance(value, unicode)
            if key == "ascii":
                asciiName = value
            else:
                otherNames[key] = value
        assert asciiName
        for index, (key, value) in enumerate(otherNames.items()):
            if index > 0:
                result += "else "
            result += "if (currentLocaleName==\"%s\") {\n" % key
            result += "    %s(QString::fromUtf8(\"%s\"));\n" % (setTitle, value)
            result += "}\n"
        default = "%s(QString::fromAscii(\"%s\"));\n" % (setTitle, asciiName)
        if otherNames:
            result += "else {\n    %s}\n" % default
        else:
            result += default
        result += "\n"
        if deep > 0 and menu.items:
            result += "m_action%s->setMenu(new QMenu);\n" % (parentPrefix + menu.title.cppCamelCaseValue())
            result += "m_action%s->menu()->setTitle(m_action%s->text());\n" % (
                parentPrefix + menu.title.cppCamelCaseValue(),
                parentPrefix + menu.title.cppCamelCaseValue()
            )
        for child in menu.items:
            result += self._add_menu_actions_creation(child,
                                                      parentPrefix + menu.title.cppCamelCaseValue(),
                                                      deep + 1)
        return result

    def constructorImplementation(self):
        """
        Creates C++ constructor implementation

        :rtype:     unicode
        :return:    implementation of C++ constructor
        """
        body = ""
        if self._module.gui:
            body += "static const QString currentLocaleName = QLocale().name();\n\n"
            for menu in self._module.gui.menus:
                body += self._add_menu_actions_creation(menu)
        return """
%s::%s(ExtensionSystem::KPlugin* parent)
    : QObject(parent)
{
%s
}
        """ % (self.className, self.className, _addIndent(body))

    def setAnimationEnabledCppImplementation(self):
        """
        Creates setAnimationEnabled implementation or returns an empty string for
        pure virtual method, if there is an implementation in derived class

        :rtype:     str
        :return:    implementation of void setAnimationEnabled(bool) or an empty string
        """
        if self._module.gui:
            return ""  # no implementation, just pure virtual method
        else:
            return """
/* public slot */ void %s::setAnimationEnabled(bool enabled)
{
    Q_UNUSED(enabled);
}
        """ % self.className

    def mainWidgetCppImplementation(self):
        """
        Creates mainWidget implementation or returns an empty string for
        pure virtual method, if there is an implementation in derived class

        :rtype:     str
        :return:    implementation of QWidget* mainWidget() or an empty string
        """
        if self._module.gui:
            return ""  # no implementation, just pure virtual method
        else:
            return """
/* public */ QWidget* %s::mainWidget() const
{
    return nullptr;
}
            """ % self.className

    def pultWidgetCppImplementation(self):
        """
        Creates pultWidget implementation or returns an empty string for
        pure virtual method, if there is an implementation in derived class

        :rtype:     str
        :return:    implementation of QWidget* pultWidget() or an empty string
        """
        if self._module.gui:
            return ""  # no implementation, just pure virtual method
        else:
            return """
/* public */ QWidget* %s::pultWidget() const
{
    return nullptr;
}
            """ % self.className

    def moduleMenusCppImplementation(self):
        """
        Creates moduleMenus implementation

        :rtype:     str
        :return:    implementation of QList<QMenu*> moduleMenus() const
        """
        body = ""
        if self._module.gui:
            for menu in self._module.gui.menus:
                assert isinstance(menu, MenuItem)
                body += "result.push_back(m_menu%s);\n" % menu.title.cppCamelCaseValue()
        return """
/* public */ QList<QMenu*> %s::moduleMenus() const
{
    QList<QMenu*> result;
%s
    return result;
}
        """ % (self.className, _addIndent(body))

    def setErrorCppImplementation(self):
        """
        Creates setError implementation

        :rtype:     str
        :return:    implementation of void setError(const QString &)
        """
        return """
/* protected */ void %s::setError(const QString & errorText)
{
    %s* plugin = qobject_cast<%s*>(parent());
    plugin->errorText_ = errorText;
}
        """ % (self.className, self._module.pluginClassName(), self._module.pluginClassName())

    def mySettingsCppImplementation(self):
        """
        Creates mySettings implementation

        :rtype:     str
        :return:    implementation of QSettings* mySettings() const
        """
        return """
/* protected */ QSettings* %s::mySettings() const
{
    %s* plugin = qobject_cast<%s*>(parent());
    return plugin->mySettings();
}
        """ % (self.className, self._module.pluginClassName(), self._module.pluginClassName())

    def sleepCppImplementation(self):
        """
        Creates sleep implementation

        :rtype:     str
        :return:    implementation of void sleep(unsigned long)
        """
        return """
/* protected */ void %s::sleep(unsigned long secs)
{
    %s* plugin = qobject_cast<%s*>(parent());
    plugin->sleep(secs);
}
        """ % (self.className, self._module.pluginClassName(), self._module.pluginClassName())

    def msleepCppImplementation(self):
        """
        Creates msleep implementation

        :rtype:     str
        :return:    implementation of void msleep(unsigned long)
        """
        return """
/* protected */ void %s::msleep(unsigned long msecs)
{
    %s* plugin = qobject_cast<%s*>(parent());
    plugin->msleep(msecs);
}
        """ % (self.className, self._module.pluginClassName(), self._module.pluginClassName())

    def usleepCppImplementation(self):
        """
        Creates usleep implementation

        :rtype:     str
        :return:    implementation of void usleep(unsigned long)
        """
        return """
/* protected */ void %s::usleep(unsigned long usecs)
{
    %s* plugin = qobject_cast<%s*>(parent());
    plugin->usleep(usecs);
}
        """ % (self.className, self._module.pluginClassName(), self._module.pluginClassName())


class ModuleCppClass(CppClassBase):
    """
    Actor module implementation C++ derived class
    """
    def __init__(self, module):
        """
        Initialized from actor module tree
        """
        assert isinstance(module, Module)
        self._module = module
        CppClassBase.__init__(self)
        self.baseClasses = [module.baseClassName()]
        self.className = module.className()
        self.classDeclarationPrefix = "    Q_OBJECT"
        for method in self._module.methods:
            stub = method.cppImplementationStub(self.className)
            self.extraImplementations.append(stub)

    def constructorImplementation(self):
        """
        Creates C++ constructor implementation stub

        :rtype:     str
        :return:    implementation of C++ constructor
        """
        return """
%s::%s(ExtensionSystem::KPlugin * parent)
    : %s(parent)
{
    // Module constructor, called once on plugin load
    // TODO implement me
}
        """ % (self.className, self.className, self._module.baseClassName())

    def mainWidgetCppImplementation(self):
        """
        Creates mainWidget implementation stub or en empty string if derived class has no implementation

        :rtype:     str
        :return:    implementation of QWidget* mainWidget() const or an empty string
        """
        if not self._module.gui:
            return ""
        else:
            return """
/* public */ QWidget* %s::mainWidget() const
{
    // Returns module main view widget, or nullptr if there is no any views
    // NOTE: the method is const and might be called at any time,
    //       so DO NOT create widget here, just return!
    // TODO implement me
    return nullptr;
}
            """ % self.className

    def pultWidgetCppImplementation(self):
        """
        Creates pultWidget implementation stub or en empty string if derived class has no implementation

        :rtype:     str
        :return:    implementation of QWidget* pultWidget() const or an empty string
        """
        if not self._module.gui:
            return ""
        else:
            return """
/* public */ QWidget* %s::pultWidget() const
{
    // Returns module control view widget, or nullptr if there is no control view
    // NOTE: the method is const and might be called at any time,
    //       so DO NOT create widget here, just return!
    // TODO implement me
    return nullptr;
}
            """ % self.className

    def resetCppImplementation(self):
        """
        Creates reset implementation stub

        :rtype:     str
        :return:    implementation of void reset()
        """
        return """
/* public slot */ void %s::reset()
{
    // Resets module to initial state before program execution
    // TODO implement me
}
        """ % self.className

    def reloadSettingsCppImplementation(self):
        """
        Creates reloadSettings implementation stub

        :rtype:     str
        :return:    implementation of void reloadSettings(QSettings*)
        """
        return """
/* public slot */ void %s::reloadSettings(QSettings * settings)
{
    // Updates setting on module load, workspace change or appliyng settings dialog
    // TODO implement me
    Q_UNUSED(settings);  // Remove this line on implementation
}
        """ % self.className

    def changeGlobalStateCppImplementation(self):
        """
        Creates changeGlobalState implementation stub

        :rtype:     str
        :return:    implementation of void changeGlobalState(GlobalState, GlobalState)
        """
        return """
/* public slot */ void %s::changeGlobalState(ExtensionSystem::GlobalState old, ExtensionSystem::GlobalState current)
{
    // Called when changed kumir state. The states are defined as enum ExtensionSystem::GlobalState:
    /*
    namespace ExtensionSystem {
        enum GlobalState {
            GS_Unlocked, // Edit mode
            GS_Observe, // Observe mode
            GS_Running, // Running mode
            GS_Input,  // User input required
            GS_Pause  // Running paused
        };
    }
    */
    // TODO implement me
    using namespace ExtensionSystem;  // not to write "ExtensionSystem::" each time in this method scope
    Q_UNUSED(old);  // Remove this line on implementation
    Q_UNUSED(current);  // Remove this line on implementation
}
        """ % self.className

    def setAnimationEnabledCppImplementation(self):
        """
        Creates setAnimationEnabled implementation stub or an empty string if derived class has no implementation

        :rtype:     str
        :return:    implementation of void setAnimationEnabled(bool) or an empty string
        """
        if not self._module.gui:
            return ""
        else:
            return """
/* public slot */ void %s::setAnimationEnabled(bool enabled)
{
    // Sets GUI animation flag on run
    // NOTE this method just setups a flag and might be called anytime, even module not needed
    // TODO implement me
    Q_UNUSED(enabled);  // Remove this line on implementation
}
            """ % self.className


# Script workflow functions

def _updateFile(fileName, targetDir, text):
    """
    Creates (if not exists) or updates (if content differs) a text file

    :type   fileName:   str
    :param  fileName:   file name to update
    :type   targetDir:  str
    :param  targetDir:  directory to store a file
    :type   text:       unicode
    :param  text:       a new text contents of file
    """
    forceRewrite = True
    assert isinstance(text, unicode)
    data = text.encode("utf-8")
    if targetDir:
        if not os.path.exists(targetDir):
            os.makedirs(targetDir)
        fileName = os.path.normpath(targetDir + os.path.sep + fileName)
    if os.path.exists(fileName):
        f = open(fileName, 'r')
        oldData = f.read()
        f.close()
        forceRewrite = oldData != data
    if forceRewrite:
        f = open(fileName, 'w')
        f.write(data)
        f.close()


def createPluginHeaderFile(module, targetDir=""):
    """
    Creates or updates module plugin header file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    assert isinstance(module, Module)
    assert isinstance(targetDir, str)
    fileBaseName = module.pluginClassName().lower()
    substitutions = {
        "headerGuard": fileBaseName.upper() + "_H",
        "namespace": module.namespace(),
        "pluginClassDeclaration": PluginCppClass(module).cppDeclaration(),
        "threadClassDeclaration": AsyncThreadCppClass(module).cppDeclaration()
    }
    data = _renderTemplate("""
/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

#ifndef $headerGuard
#define $headerGuard

// Kumir includes
#include "extensionsystem/kplugin.h"
#include "extensionsystem/declarativesettingspage.h"
#include "interfaces/actorinterface.h"

// Qt includes
#include <QtCore>
#include <QtGui>

namespace $namespace {

$pluginClassDeclaration

$threadClassDeclaration

} // namespace $namespace

#endif // $headerGuard

    """, substitutions).strip() + "\n"
    _updateFile(fileBaseName + ".h", targetDir, data)


def createPluginSourceFile(module, targetDir=""):
    """
    Creates or updates module plugin source file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    assert isinstance(module, Module)
    assert isinstance(targetDir, str)
    fileBaseName = module.pluginClassName().lower()
    substitutions = {
        "headerFileName": fileBaseName + ".h",
        "moduleBaseHeaderFileName": module.baseClassName().lower() + ".h",
        "moduleHeaderFileName": module.className().lower() + ".h",
        "namespace": module.namespace(),
        "pluginClassImplementation": PluginCppClass(module).cppImplementation(),
        "threadClassImplementation": AsyncThreadCppClass(module).cppImplementation(),
        "pluginClassName": module.pluginClassName()
    }
    data = _renderTemplate("""
/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

// Self include
#include "$headerFileName"
#include "$moduleBaseHeaderFileName"
#include "$moduleHeaderFileName"

namespace $namespace {

$pluginClassImplementation

$threadClassImplementation

} // namespace $namespace

Q_EXPORT_PLUGIN($namespace::$pluginClassName)

    """, substitutions).strip() + "\n"
    _updateFile(fileBaseName + ".cpp", targetDir, data)


def createModuleBaseHeaderFile(module, targetDir=""):
    """
    Creates or updates module implementation C++ base header file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    assert isinstance(module, Module)
    fileBaseName = module.baseClassName().lower()
    customTypeDeclarations = ""
    for typee in module.types:
        assert isinstance(typee, BaseType)
        if not typee.isStandardType():
            customTypeDeclarations += typee.cppDeclaration()
            customTypeDeclarations += typee.cppCustomTypeInlineEncodeDecode()
    substitutions = {
        "headerGuard": fileBaseName.upper() + "_H",
        "customTypeDeclarations": customTypeDeclarations,
        "namespace": module.namespace(),
        "classDeclaration": ModuleBaseCppClass(module).cppDeclaration()
    }
    data = _renderTemplate("""
/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

#ifndef $headerGuard
#define $headerGuard

// Kumir includes
#include "extensionsystem/kplugin.h"

// Qt includes
#include <QtCore>
#include <QtGui>

namespace $namespace {

$customTypeDeclarations

$classDeclaration

} // namespace $namespace

#endif // $headerGuard

    """, substitutions).strip() + "\n"
    _updateFile(fileBaseName + ".h", targetDir, data)


def createModuleBaseSourceFile(module, targetDir=""):
    """
    Creates or updates module implementation C++ base source file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    assert isinstance(module, Module)
    fileBaseName = module.baseClassName().lower()
    substitutions = {
        "selfInclude": fileBaseName + ".h",
        "pluginInclude": module.pluginClassName().lower() + ".h",
        "namespace": module.namespace(),
        "classImplementation": ModuleBaseCppClass(module).cppImplementation()
    }
    data = _renderTemplate("""
/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

// Self includes
#include "$selfInclude"
#include "$pluginInclude"

// Kumir includes
#include "extensionsystem/kplugin.h"

// Qt includes
#include <QtCore>
#include <QtGui>

namespace $namespace {

$classImplementation

} // namespace $namespace


    """, substitutions).strip() + "\n"
    _updateFile(fileBaseName + ".cpp", targetDir, data)


def createModuleHeaderFile(module, targetDir=""):
    """
    Creates or updates module implementation header file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    assert isinstance(module, Module)
    fileBaseName = module.className().lower()
    substitutions = {
        "headerGuard": fileBaseName.upper() + "_H",
        "namespace": module.namespace(),
        "baseClassHeader": module.baseClassName().lower() + ".h",
        "classDeclaration": ModuleCppClass(module).cppDeclaration()
    }
    data = _renderTemplate("""
/*
This file is generated, but you can safely change it
until you run "gen_actor_source.py" with "--project" flag.

Generated file is just a skeleton for module contents.
You should change it corresponding to functionality.
*/

#ifndef $headerGuard
#define $headerGuard

// Base class include
#include "$baseClassHeader"

// Kumir includes
#include "extensionsystem/kplugin.h"

// Qt includes
#include <QtCore>
#include <QtGui>

namespace $namespace {

$classDeclaration

} // namespace $namespace

#endif // $headerGuard
    """, substitutions).strip() + "\n"
    _updateFile(fileBaseName + ".h", targetDir, data)


def createModuleSourceFile(module, targetDir=""):
    """
    Creates or updates module implementation source file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    assert isinstance(module, Module)
    fileBaseName = module.className().lower()
    substitutions = {
        "namespace": module.namespace(),
        "selfHeader": module.className().lower() + ".h",
        "classImplementation": ModuleCppClass(module).cppImplementation()
    }
    data = _renderTemplate("""
/*
This file is generated, but you can safely change it
until you run "gen_actor_source.py" with "--project" flag.

Generated file is just a skeleton for module contents.
You should change it corresponding to functionality.
*/

// Self include
#include "$selfHeader"

// Kumir includes
#include "extensionsystem/kplugin.h"

// Qt includes
#include <QtCore>
#include <QtGui>

namespace $namespace {

$classImplementation

} // namespace $namespace

    """, substitutions).strip() + "\n"
    _updateFile(fileBaseName + ".cpp", targetDir, data)


def createPluginSpecFile(module, targetDir=""):
    """
    Creates or updates module plugin specification file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    fileName = "Actor" + module.name.cppCamelCaseValue() + ".pluginspec"
    name = "Actor" + module.name.cppCamelCaseValue()
    if module.gui:
        gui = "true"
    else:
        gui = "false"
    data = """
name    = %s
gui     = %s
    """ % (name, gui)
    _updateFile(fileName, targetDir, unicode(data.strip() + "\n"))


def createCMakeListsTxt(module, jsonFileName, targetDir=""):
    """
    Creates or updates project CMakeLists.txt file

    :type   module:         Module
    :param  module:         actor module tree root
    :type   jsonFileName:   str
    :param  jsonFileName:   name of source JSON file used to watch for changes
    :type   targetDir:      str
    :param  targetDir:      directory path to store (optional, by default uses current dir)
    """
    substitutions = {
        "moduleFileName": module.className().lower(),
        "moduleBaseFileName": module.baseClassName().lower(),
        "pluginFileName": module.pluginClassName().lower(),
        "specFileName": "Actor%s" % module.name.cppCamelCaseValue(),
        "jsonFileName": os.path.basename(jsonFileName),
        "actorDir": module.name.cppCamelCaseValue().lower()
    }
    data = _renderTemplate(r"""
set(QT_USE_QTMAIN 1)
find_package(Qt4 4.7.0 COMPONENTS QtCore QtGui REQUIRED)
find_package(PythonInterp 2.6 REQUIRED)
include (${QT_USE_FILE})
include(../../kumir2_plugin.cmake)

set(SOURCES
    $moduleFileName.cpp
)

set(MOC_HEADERS
    $moduleFileName.h
)

add_custom_command(
    OUTPUT
        ${CMAKE_CURRENT_BINARY_DIR}/$moduleBaseFileName.cpp
        ${CMAKE_CURRENT_BINARY_DIR}/$moduleBaseFileName.h
        ${CMAKE_CURRENT_BINARY_DIR}/$pluginFileName.cpp
        ${CMAKE_CURRENT_BINARY_DIR}/$pluginFileName.h
        ${CMAKE_CURRENT_BINARY_DIR}/$specFileName.pluginspec
    COMMAND ${PYTHON_EXECUTABLE}
            ${CMAKE_CURRENT_SOURCE_DIR}/../../../scripts/gen_actor_source.py
            --update
            ${CMAKE_CURRENT_SOURCE_DIR}/$jsonFileName
    DEPENDS
        ${CMAKE_CURRENT_SOURCE_DIR}/$jsonFileName
        ${CMAKE_CURRENT_SOURCE_DIR}/../../../scripts/gen_actor_source.py
)

add_custom_target(
    $specFileNamePluginSpec
    ALL
    ${CMAKE_COMMAND} -E copy
        ${CMAKE_CURRENT_BINARY_DIR}/$specFileName.pluginspec ${PLUGIN_OUTPUT_PATH}
    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/$specFileName.pluginspec
)

add_custom_command(
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/$moduleBaseFileName.moc.cpp
    COMMAND ${QT_MOC_EXECUTABLE}
        -I${CMAKE_SOURCE_DIR}/src/shared
        -o${CMAKE_CURRENT_BINARY_DIR}/$moduleBaseFileName.moc.cpp
        ${CMAKE_CURRENT_BINARY_DIR}/$moduleBaseFileName.h
    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/$moduleBaseFileName.h
)

add_custom_command(
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/$pluginFileName.moc.cpp
    COMMAND ${QT_MOC_EXECUTABLE}
        -I${CMAKE_SOURCE_DIR}/src/shared
        -o${CMAKE_CURRENT_BINARY_DIR}/$pluginFileName.moc.cpp
        ${CMAKE_CURRENT_BINARY_DIR}/$pluginFileName.h
    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/$pluginFileName.h
)

set(SOURCES_GENERATED
    $moduleBaseFileName.cpp
    $pluginFileName.cpp
)

set(MOC_SOURCES_GENERATED
    $moduleBaseFileName.moc.cpp
    $pluginFileName.moc.cpp
)

qt4_wrap_cpp(MOC_SOURCES ${MOC_HEADERS})

install(
    FILES ${PLUGIN_OUTPUT_PATH}/$specFileName.pluginspec
    DESTINATION ${PLUGINS_DIR}
)

handleTranslation($specFileName)

add_library(
    $specFileName
    SHARED
    ${MOC_SOURCES} ${SOURCES}
    ${MOC_SOURCES_GENERATED} ${SOURCES_GENERATED}
)

target_link_libraries(
    $specFileName
    ${QT_LIBRARIES}
    ExtensionSystem
)

copyResources(actors/$actorDir)

install(
    TARGETS $specFileName
    DESTINATION ${PLUGINS_DIR}
)

file(
    COPY ${CMAKE_SOURCE_DIR}/userdocs/$specFileName.xml
    DESTINATION ${SHARE_PATH}/webapps/helpviewer/data/russian
)
    """, substitutions).strip() + "\n"
    _updateFile("CMakeLists.txt", targetDir, data)


def createDocbookFile(module, targetDir):
    """
    Creates or updates module documentation DocBook XML file

    :type   module:     Module
    :param  module:     actor module tree root
    :type   targetDir:  str
    :param  targetDir:  directory path to store (optional, by default uses current dir)
    """
    fileName = "Actor" + module.name.cppCamelCaseValue() + ".xml"
    if "ru_RU" in module.name.data:
        moduleName = module.name.data["ru_RU"]
    else:
        moduleName = module.name.asciiValue()
    substitutions = {
        "moduleName": moduleName
    }
    data = _renderTemplate("""
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book
    PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "docbookV4.5/docbookx.dtd"
    []
>
<article>
    <title>$moduleName</title>
    <!--
        Write module documentation here.

        See DocBook specification for more details,
        or use some GUI tool to edit this file (like "Serna Free").

    -->
</article>

        """, substitutions).strip() + "\n"
    _updateFile(fileName, targetDir, data)


def main_update(args):
    """
    Script entry point for update mode workflow

    :type   args:   list
    :param  args:   script arguments
    :rtype:         int
    :return:        exit status
    """
    fileName = ""
    for arg in args[1:]:
        if not arg.startswith("-"):
            fileName = arg
    if not fileName:
        return main_help(args)
    f = open(fileName, 'r')
    data = json.load(f, "utf-8")
    f.close()
    module = Module(data)
    createPluginHeaderFile(module)
    createPluginSourceFile(module)
    createModuleBaseHeaderFile(module)
    createModuleBaseSourceFile(module)
    createPluginSpecFile(module)
    return 0


def main_project(args):
    """
    Script entry point for create project mode workflow

    :type   args:   list
    :param  args:   script arguments
    :rtype:         int
    :return:        exit status
    """
    fileName = ""
    for arg in args[1:]:
        if not arg.startswith("-"):
            fileName = arg
    if not fileName:
        return main_help(args)
    f = open(fileName, 'r')
    data = json.load(f, "utf-8")
    f.close()
    module = Module(data)
    createModuleHeaderFile(module)
    createModuleSourceFile(module)
    createCMakeListsTxt(module, fileName)
    createDocbookFile(module, "../../../userdocs")
    return 0


def main_help(args):
    """
    Script entry point for show help mode workflow

    :type   args:   list
    :param  args:   script arguments
    :rtype:         int
    :return:        exit status
    """
    message = __doc__[:__doc__.index("===")].strip() + "\n"
    if "--help" in args:
        sys.stdout.write(message.encode("utf-8"))
        return 0
    else:
        sys.stderr.write(message.encode("utf-8"))
        return 127


def main(args):
    """
    Script entry point

    :type   args:   list
    :param  args:   script arguments
    :rtype:         int
    :return:        exit status
    """
    if "--help" in args or len(args) < 3:
        return main_help(args)
    elif "--update" in args:
        return main_update(args)
    elif "--project" in args:
        return main_project(args)
    else:
        return main_help(args)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
