/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

// Self include
#include "vodoleyplugin.h"
#include "vodoleymodulebase.h"
#include "vodoleymodule.h"

namespace ActorVodoley {



VodoleyPlugin::VodoleyPlugin()
    : ExtensionSystem::KPlugin()
    , module_(nullptr)
    , asyncRunThread_(nullptr)
    , settingsPage_(nullptr)
{
    bool hasGuiThread = true;
#ifdef Q_OS_LINUX
    hasGuiThread = getenv("DISPLAY") != 0;
#endif
    QObject::connect(
        this, SIGNAL(asyncRun(quint32,QVariantList)),
        this, SLOT(asyncEvaluate(quint32,QVariantList)),
        //hasGuiThread? Qt::QueuedConnection :
        Qt::DirectConnection
    );
}

/* protected */ QList<ExtensionSystem::CommandLineParameter> VodoleyPlugin::acceptableCommandLineParameters() const
{
    return VodoleyModule::acceptableCommandLineParameters();
}

/* public */ QVariantList VodoleyPlugin::algOptResults() const
{
    return optResults_;
}

/* public */ QByteArray VodoleyPlugin::asciiModuleName() const
{
    return QByteArray("vodoley");
}

/* private slot */ void VodoleyPlugin::asyncEvaluate(quint32 index, const QVariantList & args)
{
    using namespace Shared;
    errorText_.clear();
    result_ = QVariant::Invalid;
    optResults_.clear();
    switch (index) {
        case 0x0000: {
            /* fill A */
            module_->runFillA();
            break;
        }
        
        case 0x0001: {
            /* fill B */
            module_->runFillB();
            break;
        }
        
        case 0x0002: {
            /* fill C */
            module_->runFillC();
            break;
        }
        
        case 0x0003: {
            /* empty A */
            module_->runEmptyA();
            break;
        }
        
        case 0x0004: {
            /* empty B */
            module_->runEmptyB();
            break;
        }
        
        case 0x0005: {
            /* empty C */
            module_->runEmptyC();
            break;
        }
        
        case 0x0006: {
            /* from A to B */
            module_->runFromAToB();
            break;
        }
        
        case 0x0007: {
            /* from A to C */
            module_->runFromAToC();
            break;
        }
        
        case 0x0008: {
            /* from B to A */
            module_->runFromBToA();
            break;
        }
        
        case 0x0009: {
            /* from B to C */
            module_->runFromBToC();
            break;
        }
        
        case 0x000a: {
            /* from C to B */
            module_->runFromCToB();
            break;
        }
        
        case 0x000b: {
            /* from C to A */
            module_->runFromCToA();
            break;
        }
        
        
        default : {
            errorText_ = "Unknown method index for async evaluation";
        }
    }
    Q_EMIT sync();
}

/* protected */ void VodoleyPlugin::changeGlobalState(ExtensionSystem::GlobalState old, ExtensionSystem::GlobalState current)
{
    module_->changeGlobalState(old, current);
}

/* public */ void VodoleyPlugin::connectSync(QObject* receiver, const char* method)
{
    QObject::connect(this, SIGNAL(sync()), receiver, method, Qt::DirectConnection);
}

/* protected */ void VodoleyPlugin::createPluginSpec()
{
    _pluginSpec.name = "ActorVodoley";
    _pluginSpec.gui = isGuiRequired();
}

/* public */ QVariant VodoleyPlugin::customValueFromString(const QByteArray & , const QString & ) const
{
    QVariant result;

    return result;
}

/* public */ QString VodoleyPlugin::customValueToString(const QByteArray & , const QVariant & ) const
{
    QString result;

    return result;
}

/* public */ QVariantList VodoleyPlugin::defaultTemplateParameters() const
{
    QVariantList result;
    return result;
}

/* public */ QString VodoleyPlugin::errorText() const
{
    return errorText_;
}

/* public */ Shared::EvaluationStatus VodoleyPlugin::evaluate(quint32 index, const QVariantList & args)
{
    using namespace Shared;
    errorText_.clear();
    result_ = QVariant::Invalid;
    optResults_.clear();
    switch (index) {
        case 0x0000: {
            /* fill A */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0001: {
            /* fill B */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0002: {
            /* fill C */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0003: {
            /* empty A */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0004: {
            /* empty B */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0005: {
            /* empty C */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0006: {
            /* from A to B */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0007: {
            /* from A to C */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0008: {
            /* from B to A */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0009: {
            /* from B to C */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x000a: {
            /* from C to B */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x000b: {
            /* from C to A */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x000c: {
            /* task complited */
            result_ = QVariant::fromValue(module_->runTaskComplited());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        case 0x000d: {
            /* size A */
            result_ = QVariant::fromValue(module_->runSizeA());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        case 0x000e: {
            /* size B */
            result_ = QVariant::fromValue(module_->runSizeB());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        case 0x000f: {
            /* size C */
            result_ = QVariant::fromValue(module_->runSizeC());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        case 0x0010: {
            /* in A */
            result_ = QVariant::fromValue(module_->runInA());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        case 0x0011: {
            /* in B */
            result_ = QVariant::fromValue(module_->runInB());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        case 0x0012: {
            /* in C */
            result_ = QVariant::fromValue(module_->runInC());
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        
        default : {
            errorText_ = "Unknown method index";
            return ES_Error;
        }
    }
}

/* public */ Shared::ActorInterface::FunctionList VodoleyPlugin::functionList() const
{
    Shared::ActorInterface::FunctionList result;
    
    /* алг наполни A */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("fill A");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("наполни A");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг наполни B */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("fill B");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("наполни B");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг наполни C */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("fill C");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("наполни C");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг вылей A */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("empty A");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("вылей A");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг вылей B */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("empty B");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("вылей B");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг вылей C */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("empty C");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("вылей C");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг перелей из A в B */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("from A to B");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("перелей из A в B");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг перелей из A в C */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("from A to C");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("перелей из A в C");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг перелей из B в A */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("from B to A");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("перелей из B в A");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг перелей из B в C */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("from B to C");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("перелей из B в C");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг перелей из C в B */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("from C to B");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("перелей из C в B");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг перелей из C в A */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("from C to A");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("перелей из C в A");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг лог @решено */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::TeacherModeFunction;
    result.last().asciiName = QByteArray("task complited");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("@решено");
    result.last().returnType = Shared::ActorInterface::Bool;
    
    /* алг цел размер A */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("size A");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("размер A");
    result.last().returnType = Shared::ActorInterface::Int;
    
    /* алг цел размер B */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("size B");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("размер B");
    result.last().returnType = Shared::ActorInterface::Int;
    
    /* алг цел размер C */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("size C");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("размер C");
    result.last().returnType = Shared::ActorInterface::Int;
    
    /* алг цел в сосуде A */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("in A");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("в сосуде A");
    result.last().returnType = Shared::ActorInterface::Int;
    
    /* алг цел в сосуде B */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("in B");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("в сосуде B");
    result.last().returnType = Shared::ActorInterface::Int;
    
    /* алг цел в сосуде C */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("in C");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("в сосуде C");
    result.last().returnType = Shared::ActorInterface::Int;
    ;
    return result;
}

/* private slot */ void VodoleyPlugin::handleSettingsChangedCppImplementation(const QStringList & keys)
{
    if (module_) {
        module_->reloadSettings(mySettings(), keys);
    }
}

/* protected */ QString VodoleyPlugin::initialize(const QStringList &a, const ExtensionSystem::CommandLine &b)
{
    module_ = new VodoleyModule(this);
    asyncRunThread_ = new VodoleyAsyncRunThread(this, module_);
    QObject::connect(asyncRunThread_, SIGNAL(finished()),
                     this, SIGNAL(sync()));
    QObject::connect(module_, SIGNAL(notifyOnTemplateParametersChanged()),
                     this, SIGNAL(notifyOnTemplateParametersChanged()));
    
    return module_->initialize(a, b);
}

/* public */ bool VodoleyPlugin::isGuiRequired() const
{
    return true;
}

/* public */ bool VodoleyPlugin::isSafeToQuit()
{
    return module_->isSafeToQuit();
}

/* public slot */ void VodoleyPlugin::loadActorData(QIODevice * source)
{
    if (module_) {
        module_->loadActorData(source);
    }
}

/* public */ QString VodoleyPlugin::localizedModuleName(const QLocale::Language ) const
{
    // TODO non-Russian languages not implemented yet
    return QString::fromUtf8("Водолей");
}

/* public */ QString VodoleyPlugin::mainIconName() const
{
    return QString::fromLatin1("vodoley");
}

/* public */ QWidget* VodoleyPlugin::mainWidget()
{
    return module_->mainWidget();
}

/* public */ QList<QMenu*> VodoleyPlugin::moduleMenus() const
{
    return module_->moduleMenus();
}

/* protected */ void VodoleyPlugin::msleep(unsigned long secs)
{
    //if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->amsleep(secs);
    //}
}

/* public */ void VodoleyPlugin::notifyGuiReady()
{
    module_->handleGuiReady();
}

/* public */ QString VodoleyPlugin::pultIconName() const
{
    return QString::fromLatin1("vodoley-pult");
}

/* public */ QWidget* VodoleyPlugin::pultWidget()
{
    return module_->pultWidget();
}

/* public */ void VodoleyPlugin::reset()
{
    module_->reset();
}

/* public */ QVariant VodoleyPlugin::result() const
{
    return result_;
}

/* public */ void VodoleyPlugin::setAnimationEnabled(bool enabled)
{
    // The module might be not created at a time of call,
    // so check it propertly
    if (module_) {
        module_->setAnimationEnabled(enabled);
    }
}

/* public */ QWidget* VodoleyPlugin::settingsEditorPage()
{
    return settingsPage_;
}

/* protected */ void VodoleyPlugin::sleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->asleep(secs);
    }
}

/* public */ QVariantList VodoleyPlugin::templateParameters() const
{
    if (module_) {
        return module_->templateParameters();
    }
    else {
        return defaultTemplateParameters();
    }
}

/* public */ void VodoleyPlugin::terminateEvaluation()
{
    module_->terminateEvaluation();
}

/* public */ Shared::ActorInterface::TypeList VodoleyPlugin::typeList() const
{
    Shared::ActorInterface::TypeList result;
    
    return result;
}

/* private */ void VodoleyPlugin::updateSettings(const QStringList & keys)
{
    if (settingsPage_) {
        settingsPage_->setSettingsObject(mySettings());
    }
    if (module_) {
        module_->reloadSettings(mySettings(), keys);
    }
}

/* public */ QList<Shared::ActorInterface*> VodoleyPlugin::usesList() const
{
    static const QList<Shared::ActorInterface*> empty = QList<Shared::ActorInterface*>();
    return empty;
}

/* protected */ void VodoleyPlugin::usleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->ausleep(secs);
    }
}



VodoleyAsyncRunThread::VodoleyAsyncRunThread(class VodoleyPlugin* plugin, class VodoleyModuleBase* module)
    : QThread(plugin)
    , index_(0)
    , args_(QVariantList())
    , plugin_(plugin)
    , module_(module)
{
}

/* public */ void VodoleyAsyncRunThread::amsleep(unsigned long secs)
{
    msleep(secs);
}

/* public */ void VodoleyAsyncRunThread::asleep(unsigned long secs)
{
    sleep(secs);
}

/* public */ void VodoleyAsyncRunThread::ausleep(unsigned long secs)
{
    usleep(secs);
}

/* public */ void VodoleyAsyncRunThread::init(quint32 index, const QVariantList & args)
{
    index_ = index;
    args_ = args;
}

/* private */ void VodoleyAsyncRunThread::run()
{
    switch (index_) {
        case 0x0000: {
            /* fill A */
            module_->runFillA();
            break;
        }
        case 0x0001: {
            /* fill B */
            module_->runFillB();
            break;
        }
        case 0x0002: {
            /* fill C */
            module_->runFillC();
            break;
        }
        case 0x0003: {
            /* empty A */
            module_->runEmptyA();
            break;
        }
        case 0x0004: {
            /* empty B */
            module_->runEmptyB();
            break;
        }
        case 0x0005: {
            /* empty C */
            module_->runEmptyC();
            break;
        }
        case 0x0006: {
            /* from A to B */
            module_->runFromAToB();
            break;
        }
        case 0x0007: {
            /* from A to C */
            module_->runFromAToC();
            break;
        }
        case 0x0008: {
            /* from B to A */
            module_->runFromBToA();
            break;
        }
        case 0x0009: {
            /* from B to C */
            module_->runFromBToC();
            break;
        }
        case 0x000a: {
            /* from C to B */
            module_->runFromCToB();
            break;
        }
        case 0x000b: {
            /* from C to A */
            module_->runFromCToA();
            break;
        }
        
        default: {
            plugin_->errorText_ = "Unknown method index";
        }
    }
}



} // namespace ActorVodoley
#if QT_VERSION < 0x050000
Q_EXPORT_PLUGIN(ActorVodoley::VodoleyPlugin)
#endif
