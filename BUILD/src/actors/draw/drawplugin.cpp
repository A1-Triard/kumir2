/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

// Self include
#include "drawplugin.h"
#include "drawmodulebase.h"
#include "drawmodule.h"

namespace ActorDraw {


QVariant encode(const Color & record) {
    QVariantList result;
    result << QVariant(record.r);
    result << QVariant(record.g);
    result << QVariant(record.b);
    result << QVariant(record.a);

    return result;
}

Color decode(const QVariant & raw) {
    Color result;
    const QVariantList alist = raw.toList();
    result.r = alist.size() > 0 ? alist.at(0).toInt() : 0;
    result.g = alist.size() > 1 ? alist.at(1).toInt() : 0;
    result.b = alist.size() > 2 ? alist.at(2).toInt() : 0;
    result.a = alist.size() > 3 ? alist.at(3).toInt() : 0;

    return result;
}
            


DrawPlugin::DrawPlugin()
    : ExtensionSystem::KPlugin()
    , module_(nullptr)
    , asyncRunThread_(nullptr)
    , settingsPage_(nullptr)
{
    bool hasGuiThread = true;
#ifdef Q_OS_LINUX
    hasGuiThread = getenv("DISPLAY") != 0;
#endif
    QObject::connect(
        this, SIGNAL(asyncRun(quint32,QVariantList)),
        this, SLOT(asyncEvaluate(quint32,QVariantList)),
        //hasGuiThread? Qt::QueuedConnection :
        Qt::DirectConnection
    );
}

/* protected */ QList<ExtensionSystem::CommandLineParameter> DrawPlugin::acceptableCommandLineParameters() const
{
    return DrawModule::acceptableCommandLineParameters();
}

/* public */ QVariantList DrawPlugin::algOptResults() const
{
    return optResults_;
}

/* public */ QByteArray DrawPlugin::asciiModuleName() const
{
    return QByteArray("Draw");
}

/* private slot */ void DrawPlugin::asyncEvaluate(quint32 index, const QVariantList & args)
{
    using namespace Shared;
    errorText_.clear();
    result_ = QVariant::Invalid;
    optResults_.clear();
    switch (index) {
        case 0x0005: {
            /* add caption */
            qreal width = qvariant_cast<qreal>(args[0]);
            QString text = qvariant_cast<QString>(args[1]);
            module_->runAddCaption(width, text);
            optResults_ << QVariant::Invalid;
            optResults_ << QVariant::Invalid;
            break;
        }
        
        
        default : {
            errorText_ = "Unknown method index for async evaluation";
        }
    }
    Q_EMIT sync();
}

/* protected */ void DrawPlugin::changeGlobalState(ExtensionSystem::GlobalState old, ExtensionSystem::GlobalState current)
{
    module_->changeGlobalState(old, current);
}

/* public */ void DrawPlugin::connectSync(QObject* receiver, const char* method)
{
    QObject::connect(this, SIGNAL(sync()), receiver, method, Qt::DirectConnection);
}

/* protected */ void DrawPlugin::createPluginSpec()
{
    _pluginSpec.name = "ActorDraw";
    _pluginSpec.gui = isGuiRequired();
}

/* public */ QVariant DrawPlugin::customValueFromString(const QByteArray & , const QString & ) const
{
    QVariant result;

    return result;
}

/* public */ QString DrawPlugin::customValueToString(const QByteArray & , const QVariant & ) const
{
    QString result;

    return result;
}

/* public */ QVariantList DrawPlugin::defaultTemplateParameters() const
{
    QVariantList result;
    return result;
}

/* public */ QString DrawPlugin::errorText() const
{
    return errorText_;
}

/* public */ Shared::EvaluationStatus DrawPlugin::evaluate(quint32 index, const QVariantList & args)
{
    using namespace Shared;
    errorText_.clear();
    result_ = QVariant::Invalid;
    optResults_.clear();
    switch (index) {
        case 0x0000: {
            /* setup pen */
            module_->runSetupPen();
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_NoResult;
            break;
        }
        
        case 0x0001: {
            /* release pen */
            module_->runReleasePen();
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_NoResult;
            break;
        }
        
        case 0x0002: {
            /* set pen color */
            Color color = decode(args[0]);
            module_->runSetPenColor(color);
            optResults_ << QVariant::Invalid;
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_NoResult;
            break;
        }
        
        case 0x0003: {
            /* move to */
            qreal x = qvariant_cast<qreal>(args[0]);
            qreal y = qvariant_cast<qreal>(args[1]);
            module_->runMoveTo(x, y);
            optResults_ << QVariant::Invalid;
            optResults_ << QVariant::Invalid;
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_NoResult;
            break;
        }
        
        case 0x0004: {
            /* move by */
            qreal dX = qvariant_cast<qreal>(args[0]);
            qreal dY = qvariant_cast<qreal>(args[1]);
            module_->runMoveBy(dX, dY);
            optResults_ << QVariant::Invalid;
            optResults_ << QVariant::Invalid;
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_NoResult;
            break;
        }
        
        case 0x0005: {
            /* add caption */
            Q_EMIT asyncRun(index, args);
            return ES_Async;
            break;
        }
        
        case 0x0006: {
            /* @is line at circle */
            qreal x = qvariant_cast<qreal>(args[0]);
            qreal y = qvariant_cast<qreal>(args[1]);
            qreal radius = qvariant_cast<qreal>(args[2]);
            result_ = QVariant::fromValue(module_->runIsLineAtCircle(x, y, radius));
            optResults_ << QVariant::Invalid;
            optResults_ << QVariant::Invalid;
            optResults_ << QVariant::Invalid;
            if (errorText_.length() > 0) {
                return ES_Error;
            }
            return ES_StackResult;
            break;
        }
        
        
        default : {
            errorText_ = "Unknown method index";
            return ES_Error;
        }
    }
}

/* public */ Shared::ActorInterface::FunctionList DrawPlugin::functionList() const
{
    Shared::ActorInterface::FunctionList result;
    
    /* алг опустить перо */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("setup pen");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("опустить перо");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг поднять перо */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("release pen");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("поднять перо");
    result.last().returnType = Shared::ActorInterface::Void;
    
    /* алг выбрать чернила(цвет color) */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("set pen color");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("выбрать чернила");
    result.last().returnType = Shared::ActorInterface::Void;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::RecordType;
    {
        Shared::ActorInterface::RecordSpecification recordSpec;
        recordSpec.record.push_back(Shared::ActorInterface::Field(QByteArray("r"), Shared::ActorInterface::Int));
        recordSpec.record.push_back(Shared::ActorInterface::Field(QByteArray("g"), Shared::ActorInterface::Int));
        recordSpec.record.push_back(Shared::ActorInterface::Field(QByteArray("b"), Shared::ActorInterface::Int));
        recordSpec.record.push_back(Shared::ActorInterface::Field(QByteArray("a"), Shared::ActorInterface::Int));
        recordSpec.asciiName = QByteArray("color");
         recordSpec.localizedNames[QLocale::Russian] = QString::fromUtf8("цвет");
        result.last().arguments.last().typeSpecification = recordSpec;
    }
    result.last().arguments.last().dimension = 0u;
    
    /* алг сместиться в точку(вещ x, вещ y) */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("move to");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("сместиться в точку");
    result.last().returnType = Shared::ActorInterface::Void;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    
    /* алг сместиться на вектор(вещ dX, вещ dY) */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("move by");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("сместиться на вектор");
    result.last().returnType = Shared::ActorInterface::Void;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    
    /* алг написать(вещ width, лит text) */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::PublicFunction;
    result.last().asciiName = QByteArray("add caption");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("написать");
    result.last().returnType = Shared::ActorInterface::Void;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::String;
    result.last().arguments.last().dimension = 0u;
    
    /* алг лог @есть отрезок в области(вещ x, вещ y, вещ radius) */
    result.push_back(Shared::ActorInterface::Function());
    result.last().id = result.size() - 1;
    result.last().accessType = Shared::ActorInterface::TeacherModeFunction;
    result.last().asciiName = QByteArray("@is line at circle");
    result.last().localizedNames[QLocale::Russian] = QString::fromUtf8("@есть отрезок в области");
    result.last().returnType = Shared::ActorInterface::Bool;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    result.last().arguments.push_back(Shared::ActorInterface::Argument());
    result.last().arguments.last().accessType = Shared::ActorInterface::InArgument;
    result.last().arguments.last().type = Shared::ActorInterface::Real;
    result.last().arguments.last().dimension = 0u;
    ;
    return result;
}

/* private slot */ void DrawPlugin::handleSettingsChangedCppImplementation(const QStringList & keys)
{
    if (module_) {
        module_->reloadSettings(mySettings(), keys);
    }
}

/* protected */ QString DrawPlugin::initialize(const QStringList &a, const ExtensionSystem::CommandLine &b)
{
    module_ = new DrawModule(this);
    QMap<QString,Widgets::DeclarativeSettingsPage::Entry> entries;
    
    {
        Widgets::DeclarativeSettingsPage::Entry entry;
        entry.title = QString::fromUtf8("Цвет осей");  // TODO non-Russian language support
        entry.type = Widgets::DeclarativeSettingsPage::Color;
        entry.defaultValue = QString::fromUtf8("#999900");
        entry.minimumValue = QVariant::Invalid;
        entry.maximumValue = QVariant::Invalid;
        entry.displayOrder = 99999999;
        entries["AxisColor"] = entry;
    }
            
    {
        Widgets::DeclarativeSettingsPage::Entry entry;
        entry.title = QString::fromUtf8("Толщина осей");  // TODO non-Russian language support
        entry.type = Widgets::DeclarativeSettingsPage::Integer;
        entry.defaultValue = 2;
        entry.minimumValue = QVariant::Invalid;
        entry.maximumValue = QVariant::Invalid;
        entry.displayOrder = 99999999;
        entries["AxisWidth"] = entry;
    }
            
    {
        Widgets::DeclarativeSettingsPage::Entry entry;
        entry.title = QString::fromUtf8("Цвет фона");  // TODO non-Russian language support
        entry.type = Widgets::DeclarativeSettingsPage::Color;
        entry.defaultValue = QString::fromUtf8("#99FF99");
        entry.minimumValue = QVariant::Invalid;
        entry.maximumValue = QVariant::Invalid;
        entry.displayOrder = 99999999;
        entries["BackColor"] = entry;
    }
            
    {
        Widgets::DeclarativeSettingsPage::Entry entry;
        entry.title = QString::fromUtf8("Цвет сетки");  // TODO non-Russian language support
        entry.type = Widgets::DeclarativeSettingsPage::Color;
        entry.defaultValue = QString::fromUtf8("#669966");
        entry.minimumValue = QVariant::Invalid;
        entry.maximumValue = QVariant::Invalid;
        entry.displayOrder = 99999999;
        entries["LineColor"] = entry;
    }
            
    {
        Widgets::DeclarativeSettingsPage::Entry entry;
        entry.title = QString::fromUtf8("Толщина линий");  // TODO non-Russian language support
        entry.type = Widgets::DeclarativeSettingsPage::Integer;
        entry.defaultValue = 4;
        entry.minimumValue = QVariant::Invalid;
        entry.maximumValue = QVariant::Invalid;
        entry.displayOrder = 99999999;
        entries["LineWidth"] = entry;
    }
            
    {
        Widgets::DeclarativeSettingsPage::Entry entry;
        entry.title = QString::fromUtf8("Толщина сетки");  // TODO non-Russian language support
        entry.type = Widgets::DeclarativeSettingsPage::Integer;
        entry.defaultValue = 1;
        entry.minimumValue = QVariant::Invalid;
        entry.maximumValue = QVariant::Invalid;
        entry.displayOrder = 99999999;
        entries["NetWidth"] = entry;
    }
            
    bool guiAvailable = true;
    #ifdef Q_OS_LINUX
    guiAvailable = 0 != getenv("DISPLAY");
    #endif
    if (guiAvailable) {
        settingsPage_ = new Widgets::DeclarativeSettingsPage(
                                Shared::actorCanonicalName(localizedModuleName(QLocale::Russian)),
                                mySettings(),
                                entries
                              );
        connect(settingsPage_, SIGNAL(settingsChanged(QStringList)), this, SLOT(handleSettingsChangedCppImplementation(QStringList)));
    }
    
    asyncRunThread_ = new DrawAsyncRunThread(this, module_);
    QObject::connect(asyncRunThread_, SIGNAL(finished()),
                     this, SIGNAL(sync()));
    QObject::connect(module_, SIGNAL(notifyOnTemplateParametersChanged()),
                     this, SIGNAL(notifyOnTemplateParametersChanged()));
    
    return module_->initialize(a, b);
}

/* public */ bool DrawPlugin::isGuiRequired() const
{
    return true;
}

/* public */ bool DrawPlugin::isSafeToQuit()
{
    return module_->isSafeToQuit();
}

/* public slot */ void DrawPlugin::loadActorData(QIODevice * source)
{
    if (module_) {
        module_->loadActorData(source);
    }
}

/* public */ QString DrawPlugin::localizedModuleName(const QLocale::Language ) const
{
    // TODO non-Russian languages not implemented yet
    return QString::fromUtf8("Чертежник");
}

/* public */ QString DrawPlugin::mainIconName() const
{
    return QString::fromLatin1("draw");
}

/* public */ QWidget* DrawPlugin::mainWidget()
{
    return module_->mainWidget();
}

/* public */ QList<QMenu*> DrawPlugin::moduleMenus() const
{
    return module_->moduleMenus();
}

/* protected */ void DrawPlugin::msleep(unsigned long secs)
{
    //if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->amsleep(secs);
    //}
}

/* public */ void DrawPlugin::notifyGuiReady()
{
    module_->handleGuiReady();
}

/* public */ QString DrawPlugin::pultIconName() const
{
    return QString::fromLatin1("");
}

/* public */ QWidget* DrawPlugin::pultWidget()
{
    return module_->pultWidget();
}

/* public */ void DrawPlugin::reset()
{
    module_->reset();
}

/* public */ QVariant DrawPlugin::result() const
{
    return result_;
}

/* public */ void DrawPlugin::setAnimationEnabled(bool enabled)
{
    // The module might be not created at a time of call,
    // so check it propertly
    if (module_) {
        module_->setAnimationEnabled(enabled);
    }
}

/* public */ QWidget* DrawPlugin::settingsEditorPage()
{
    return settingsPage_;
}

/* protected */ void DrawPlugin::sleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->asleep(secs);
    }
}

/* public */ QVariantList DrawPlugin::templateParameters() const
{
    if (module_) {
        return module_->templateParameters();
    }
    else {
        return defaultTemplateParameters();
    }
}

/* public */ void DrawPlugin::terminateEvaluation()
{
    module_->terminateEvaluation();
}

/* public */ Shared::ActorInterface::TypeList DrawPlugin::typeList() const
{
    Shared::ActorInterface::TypeList result;
    
            
    return result;
}

/* private */ void DrawPlugin::updateSettings(const QStringList & keys)
{
    if (settingsPage_) {
        settingsPage_->setSettingsObject(mySettings());
    }
    if (module_) {
        module_->reloadSettings(mySettings(), keys);
    }
}

/* public */ QList<Shared::ActorInterface*> DrawPlugin::usesList() const
{
    static const QList<QByteArray> usesNames = QList<QByteArray>()
        << "Actor_Colorer" ;
    QList<Shared::ActorInterface*> result;
    Q_FOREACH (const QByteArray & name, usesNames) {
        ExtensionSystem::KPlugin * plugin = myDependency(name);
        Shared::ActorInterface * actor =
                qobject_cast<Shared::ActorInterface*>(plugin);
        result.push_back(actor);
    }
    return result;
}

/* protected */ void DrawPlugin::usleep(unsigned long secs)
{
    if (QThread::currentThread()==asyncRunThread_) {
        asyncRunThread_->ausleep(secs);
    }
}



DrawAsyncRunThread::DrawAsyncRunThread(class DrawPlugin* plugin, class DrawModuleBase* module)
    : QThread(plugin)
    , index_(0)
    , args_(QVariantList())
    , plugin_(plugin)
    , module_(module)
{
}

/* public */ void DrawAsyncRunThread::amsleep(unsigned long secs)
{
    msleep(secs);
}

/* public */ void DrawAsyncRunThread::asleep(unsigned long secs)
{
    sleep(secs);
}

/* public */ void DrawAsyncRunThread::ausleep(unsigned long secs)
{
    usleep(secs);
}

/* public */ void DrawAsyncRunThread::init(quint32 index, const QVariantList & args)
{
    index_ = index;
    args_ = args;
}

/* private */ void DrawAsyncRunThread::run()
{
    switch (index_) {
        case 0x0005: {
            /* add caption */
            qreal width = qvariant_cast<qreal>(args_[0]);
            QString text = qvariant_cast<QString>(args_[1]);
            module_->runAddCaption(width, text);
            plugin_->optResults_ << QVariant::Invalid;
            plugin_->optResults_ << QVariant::Invalid;
            break;
        }
        
        default: {
            plugin_->errorText_ = "Unknown method index";
        }
    }
}



} // namespace ActorDraw
#if QT_VERSION < 0x050000
Q_EXPORT_PLUGIN(ActorDraw::DrawPlugin)
#endif
