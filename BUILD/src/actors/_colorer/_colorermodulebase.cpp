/*
DO NOT EDIT THIS FILE!

This file is autogenerated from "--update" and will be replaced
every build time

*/

// Self includes
#include "_colorermodulebase.h"
#include "_colorerplugin.h"

// Kumir includes
#include <kumir2-libs/extensionsystem/kplugin.h>

// Qt includes
#include <QtCore>
#include <QtGui>

namespace Actor_Colorer {

_ColorerModuleBase::_ColorerModuleBase(ExtensionSystem::KPlugin* parent)
    : QObject(parent)
{
    bool hasGui = true;
#ifdef Q_OS_LINUX
    hasGui = getenv("DISPLAY")!=0;
#endif
    if (hasGui) {
        
    }
}

/* protected */ const ExtensionSystem::CommandLine& _ColorerModuleBase::commandLineParameters() const
{
    _ColorerPlugin * plugin = qobject_cast<_ColorerPlugin*>(parent());
    return plugin->commandLineParameters_;
}

/* public virtual */ void _ColorerModuleBase::handleGuiReady()
{
}

/* public virtual */ QString _ColorerModuleBase::initialize(const QStringList &configurationParameters, const ExtensionSystem::CommandLine & runtimeParameters)
{
    Q_UNUSED(configurationParameters);
    Q_UNUSED(runtimeParameters);

    // Return error text or an empty string on successfull  initialization
    return QString();
}

/* public virtual */ bool _ColorerModuleBase::isSafeToQuit()
{
    return true;
}

/* public virtual slot */ void _ColorerModuleBase::loadActorData(QIODevice * source)
{
    Q_UNUSED(source);  // By default do nothing

}

/* public */ QWidget* _ColorerModuleBase::mainWidget() const
{
    return nullptr;
}

/* public */ QList<QMenu*> _ColorerModuleBase::moduleMenus() const
{
    bool hasGui = true;
#ifdef Q_OS_LINUX
    hasGui = getenv("DISPLAY")!=0;
#endif
    if (hasGui) {
        QList<QMenu*> result;
        
        return result;
    }
    else {
        return QList<QMenu*>();
    }
}

/* protected */ void _ColorerModuleBase::msleep(unsigned long msecs)
{
    _ColorerPlugin* plugin = qobject_cast<_ColorerPlugin*>(parent());
    plugin->msleep(msecs);
}

/* public */ QDir _ColorerModuleBase::myResourcesDir() const
{
    _ColorerPlugin* plugin = qobject_cast<_ColorerPlugin*>(parent());
    return plugin->myResourcesDir();
}

/* public */ ExtensionSystem::SettingsPtr _ColorerModuleBase::mySettings() const
{
    _ColorerPlugin* plugin = qobject_cast<_ColorerPlugin*>(parent());
    return plugin->mySettings();
}

/* public */ QWidget* _ColorerModuleBase::pultWidget() const
{
    return nullptr;
}

/* public virtual slot */ void _ColorerModuleBase::setAnimationEnabled(bool enabled)
{
    Q_UNUSED(enabled);
}

/* protected */ void _ColorerModuleBase::setError(const QString & errorText)
{
    _ColorerPlugin* plugin = qobject_cast<_ColorerPlugin*>(parent());
    plugin->errorText_ = errorText;
}

/* protected */ void _ColorerModuleBase::sleep(unsigned long secs)
{
    _ColorerPlugin* plugin = qobject_cast<_ColorerPlugin*>(parent());
    plugin->sleep(secs);
}

/* public virtual */ QVariantList _ColorerModuleBase::templateParameters() const
{
    _ColorerPlugin * plugin = qobject_cast<_ColorerPlugin*>(parent());
    return plugin->defaultTemplateParameters();
}

/* protected */ void _ColorerModuleBase::usleep(unsigned long usecs)
{
    _ColorerPlugin* plugin = qobject_cast<_ColorerPlugin*>(parent());
    plugin->usleep(usecs);
}



} // namespace Actor_Colorer
